"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryLimits = void 0;
var graphql_tag_1 = __importDefault(require("graphql-tag"));
exports.queryLimits = {
    samples: 1000,
    sites: 1000,
    boxes: 1000,
    projects: 1000,
    taxonomy: 1000,
    predictors: 500,
    models: 500,
    sitePredictorValues: 500,
    modelPredictors: 500,
    modelResults: 500,
    translations: 500,
    metrics: 1000
};
<<<<<<< HEAD
var typeDefs = graphql_tag_1.default(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    schema {\n        query: Query\n        mutation: Mutation\n    }\n\n    type Query {\n        # Get a project and associated metadata\n        auth: AuthParams\n\n        ####################################################################################################################################################################################\n        # Geo queries\n\n        \"Detailed information about a single site. Includes the point location and upstream catchment geometries as GeoJSON.\"\n        siteInfo(siteId: Int!): SiteInfo\n\n        \"Detailed information about a single model, including the number of predictors associated with the model.\"\n        modelInfo(modelId: Int!): ModelInfo\n\n        \"List of all model conditions (e.g. good, fair, poor) for a particular model\"\n        modelConditions(modelId: Int!): PaginatedModelConditions\n\n        ####################################################################################################################################################################################\n        # Sample queries\n\n        # \"Detailed information about a single sample, including information about the box and customer.\"\n        # sampleInfo(sampleId: Int!): SampleInfo\n\n        \"Detailed information about a single box, including information about the customer and number of samples associated with the box.\"\n        boxInfo(boxId: Int!): BoxInfo\n\n        \"List of all samples in the system, including high level information about the associated box and customer.\"\n        samples(limit: Int = ", ", offset: Int = 0, sampleIds: [Int], boxIds: [Int], projectIds: [Int], entityIds: [Int], siteIds: [Int], polygon: String, pointDistance: QueryDistance): PaginatedSamples\n\n        \"Summary information for all sites, including location coordinates and number of samples. Use the siteInfo query to get more detailed information about a single site.\"\n        sites(limit: Int = ", ", offset: Int = 0, usState: [String], sampleIds: [Int], boxIds: [Int], projectIds: [Int], entityIds: [Int], siteIds: [Int], polygon: String, pointDistance: QueryDistance): PaginatedSites\n        \n        # individuals(limit: Int, offset: Int): [Individual]\n        \"Summary information for all boxes, including the customer name and number of samples within the box. Use the boxInfo query to get more detailed information about a single box.\"\n        boxes(limit: Int = ", ", offset: Int = 0, boxIds: [Int], entityIds: [Int]): PaginatedBoxes\n\n        \"Summary information about all projects in the system. Use the projectInfo query to get more detailed about a single project.\"\n        projects(limit: Int = ", ", offset: Int = 0): PaginatedProjects\n\n        \"List of all predictors in the system. Includes summary information about how many models rely on each predictor.\"\n        predictors(modelId: Int, limit: Int = ", ", offset: Int = 0): PaginatedPredictors\n\n        \"List of all models in the system. Includes summary information about how many predictors are used by the model as well as the translation that might be required.\"\n        models(limit: Int = ", ", offset: Int = 0): PaginatedModels\n\n        \"List of predictor values at a single site. Site predictors are non-temporal. The value is common to all samples at the specific site.\"\n        sitePredictorValues(siteId: Int!, limit: Int = ", ", offset: Int = 0): PaginatedSitePredictorValues\n\n        \"List of all predictor values for a single sample. This includes both temporal and non-temporal predictors as well as their calculation status (current, missing, expired).\"\n        samplePredictorValues(sampleId: Int!): PaginatedSamplePredictorValue\n\n        \"List of predictors required by a single model.\"\n        modelPredictors(limit: Int = ", ", offset: Int = 0, modelId: Int!): PaginatedModelPredictors\n\n        modelResults(limit: Int = ", ", offset: Int = 0, sampleIds: [Int]!): PaginatedModelResult\n\n        ####################################################################################################################################################################################\n        # Taxonomy queries\n\n        \"List of all taxa in the system. Includes information about each level of the taxonomic hierarchy above each taxa.\"\n        taxonomy(limit: Int = ", ", offset: Int = 0): PaginatedTaxonomies\n\n        \"list all parents for a particular taxa\"\n        taxonomyTree(taxonomyId: Int!): PaginatedTaxonomyTree\n\n        \"List of all attributes in the system.\"\n        attributes(limit: Int = ", ", offset: Int = 0): PaginatedAttributes\n\n        \"List of all attributes that exist for a single taxa\"\n        taxaAttributes(taxonomyId: Int, limit: Int = ", ", offset: Int = 0): PaginatedAttributeValues\n  \n        \"List all the taxa within a specific translation (OTU)\"\n        translationTaxa(limit: Int = ", ", offset: Int = 0, translationId: Int!): PaginatedTranslationTaxa\n       \n        \"List of all translations in the system.\"\n        translations(limit: Int = ", ", offset: Int = 0): PaginatedTranslations\n\n        ####################################################################################################################################################################################\n        # Sample side table queries\n\n        \"List of all plankton samples in the system.\"\n        planktonSamples(limit: Int = ", ", offset: Int = 0): PaginatedPlankton\n\n        \"List of all drift samples in the system.\"\n        driftSamples(limit: Int = ", ", offset: Int = 0): PaginatedDrift\n\n        \"List of all fish samples in the system.\"\n        fishSamples(limit: Int = ", ", offset: Int = 0): PaginatedFish\n\n        \"List of all mass samples in the system.\"\n        massSamples(limit: Int = ", ", offset: Int = 0): PaginatedMass\n\n        \"List all fish diet samples in the system\"\n        fishDiet(limit: Int = ", ", offset: Int = 0, sampleIds: [Int]): PaginatedFishDiet\n\n        ####################################################################################################################################################################################\n        # Sample Taxa queries\n        \n        \"Sample organisms summed by taxonomy only. Includes both raw counts as well as counts corrected for lab and field split. Also includes both raw and corrected big rare counts.\"\n        sampleTaxaRaw(sampleIds: [Int], boxIds: [Int], projectIds: [Int]): PaginatedRawSampleTaxa\n\n        \"Sample organisms summed by taxonomy, life stage and bug size. Includes both raw counts as well as counts corrected for lab and field split. Also includes both raw and corrected big rare counts.\"\n        sampleTaxaGeneralized(sampleId: Int!): PaginatedGeneralizedSampleTaxa\n\n        \"Sample organisms converted to a translation (OTU). Rolls up counts to those taxa present in the translation and omits any organisms that don't roll up to a taxa in the translation.\"\n        sampleTaxaTranslation(sampleId: Int!, translationId: Int!): PaginatedSampleTranslationTaxa\n\n        # \"Sample organisms in their original taxonomic designation but rarefied to the specified fixed count.\"\n        # sampleTaxaRarefied(sampleId: Int!, fixedCount: Int!): PaginatedRarefiedSampleTaxa\n\n        \"Sample organisms converted to the translation (OTU) and then rarefied to the specified fixed count.\"\n        sampleTaxaTranslationRarefied(sampleId: Int!, translationId: Int!, fixedCount:Int!):PaginatedRarefiedSampleTaxa\n\n        \"Sample organisms within distance (meters) of a point (decimal degrees)\"\n        pointTaxaRaw(longitude: Float!, latitude: Float!, distance: Float!): PaginatedRawSampleTaxa\n   \n        \"Sample organisms within a polygon\"\n        polygonTaxaRaw(polygon: String!): PaginatedRawSampleTaxa\n\n        ####################################################################################################################################################################################\n        # Metric queries\n\n        metrics(limit: Int = ", ", offset: Int = 0): PaginatedMetrics\n\n        sampleMetrics(sampleIds: [Int], boxIds: [Int], projectIds: [Int], translationId: Int!, fixedCount: Int!): PaginatedMetricResult\n    }\n\n    # this schema allows the following mutation:\n    type Mutation {\n        \"Store a non-temporal predictor value for a specific site. See setSamplePredictorValue if you want to store a temporal predictor value associated with a particular sample.\"\n        setSitePredictorValue(siteId: Int!, predictorId: Int!, value:String!): Int\n\n        \"Store a temporal predictor value for a specific sample. Set setSitePredictorValue if you want to store a temporal predictor value associated with a particular site.\"\n        setSamplePredictorValue(sampleId: Int!, predictorId: Int!, value: String!): Int\n\n        \"Store the upstream catchment polygon for a specific site. The catchment polygon must be a valid, non-empty GeoJSON polygon that partially or entirely intersects with the United States.\"\n        setSiteCatchment(siteId: Int!, catchment: String!): Int\n\n        \"Create a new translation. The name is mandatory and cannot be an empty string. The description is optional.\"\n        createTranslation(translationName: String!, description: String): Int\n\n        \"Add or update a taxa associated with a translation\"\n        setTranslationTaxa(translationId: Int!, taxonomyId: Int!, alias:String, isFinal: Boolean): Int\n\n        \"Permanently remove a taxa from a translation\"\n        deleteTranslationTaxa(translationId: Int!, taxonomyId: Int!): Int\n  \n        \"Update information related to a specific taxa. Change its scientific name, move its level or change its parent\"\n        setTaxonomy(taxonomyId: Int!, scientificName: String!, levelId: Int!, parentId: Int!, author: String, year:String, notes: String, metadata:String): Int\n\n        createProject(projectName: String!, isPrivate: Boolean, description: String, metadata: String, contactId: Int): Int\n\n        addProjectSamples(projectId: Int!, sampleIds: [Int]): Int\n\n        addProjectBoxes(projectId: Int!, boxIds: [Int]): Int\n\n        removeProjectSamples(projectId: Int!, sampleIds:[Int]): Int\n\n        deleteProject(projectId: Int!): Int\n    }\n\n    input QueryDistance {\n        latitude: Float!\n        longitude: Float!\n        distance: Float!\n    }\n\n    type AuthParams {\n        loggedIn: Boolean\n        userPool: String\n        clientId: String\n        region: String\n        domain: String\n    }\n\n    type Sample {          \n        sampleId: Int\n        boxId: Int\n        customerName: String\n        customerAbbreviation: String\n        submittedBy: String\n        boxState: String\n        siteId: Int\n        siteName: String\n        usState: String\n        siteLocation: String\n        siteLongitude: Float\n        siteLatitude: Float\n        visitId: String\n        customerSiteCode: String\n        sampleDate: String\n        sampleTime: String\n        sampleType: String\n        sampleMethod: String\n        habitat: String\n        sampleLocation: String\n        sampleLongitude: Float\n        sampleLatitude: Float\n        area: Float\n        fieldSplit: Float\n        fieldNotes: String\n        labSplit: Float\n        jarCount: Int\n        qualitative: Boolean\n        labNotes: String\n        mesh: Int\n        createdDate: String\n        updatedDate: String\n        sampleDateChanged: String\n        qaSampleId: Int\n        metadata: String\n    }\n\n    type Site {\n        siteId: Int\n        siteName: String\n        system: String\n        ecosystem: String\n        longitude: Float\n        latitude: Float\n        usState: String\n        waterbodyType: String\n        waterbodyCode: String\n        waterbodyName: String\n        createdDate: String\n        updatedDate: String\n        hasCatchment: Boolean\n    }\n\n\"\"\"\nDetailed information about a single NAMC site.\n\nThis query includes the point and catchment geometries for the site.\nIt also includes the number of samples available at a particular site.\n\nMore succinct information is available for all sites using the\nsites API endpoint.\n\"\"\"\n    type SiteInfo {\n        \n        \"Unique database generated integer that uniquely identifies each site\"\n        siteId: Int\n\n        \"Unique text identifier for each site\"\n        siteName: String\n        \n        \"The ecological system (e.g. lake, pond, reservoir) in which the site is located.\"\n        system: String\n\n        \"The ecosystem in which the site is located.\"\n        ecosystem: String\n\n        \"GeoJSON point location of the site in [EPSG:4326](https://epsg.io/4326) spatial reference.\"\n        location: String\n\n        \"Longtidue of the site location in decimal degrees.\"\n        longitude: Float\n\n        \"Latitude of the site location in decimal degrees.\"\n        latitude: Float\n\n        \"US State in which the site is located.\"\n        usState: String\n\n        \"\"\"\n        If the site has a waterbody code, then the waterbody type identifies the system that\n        this identifier pertains to. The waterbody type might be NHDPlus 1:100,000 or \n        NHDPlusHR 1:24,000 etc.\n        \"\"\"\n        waterbodyType: String\n\n        \"\"\"\n        The identifier of the waterbody on which this site occurs. Can be null. If a \n        waterbody code exists, then the waterbodyType can be used to determine which\n        system the code belongs to, such as NHDPlus or NHDPlusHR.\n        \"\"\"\n        waterbodyCode: String\n\n        \"The string name of the waterbody on which the site occurs. Typicall this is the stream name.\"\n        waterbodyName: String\n\n        \"The latest date and time that either the site location (point) or catchment (polygon) were changed.\"\n        geographyChanged: String\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"GeoJSON polygon of the upstream area that drains into this site in [EPSG:4326](https://epsg.io/4326) spatial reference.\"\n        catchment: String\n\n        \"The number of samples that are available for this site.\"\n        sampleCount: Int\n    }\n\n    \"\"\"\"\n    Raw summary of organisms for a single sample. The data are returned with their original\n    laboratory taxonomic identification.\n    \"\"\"\n    type RawSampleTaxa {\n\n        \"The sample to which the taxa belong\"\n        sampleId: Int\n\n        \"The taxa identified within the laboratory.\"\n        taxonomyId: Int\n        \"The name of the taxa identified with the laboratory.\"\n        scientificName: String\n        \"The taxonomic level of the taxa identified within the laboratory.\"\n        levelId: Int\n        \"The taxonomic level of the taxa identified within the laboratory.\"\n        levelName: String\n        \"Sum of the split_counts recorded within the laboratory for this taxa. No other manipulation.\"\n        rawCount: Float\n        \n        \"\"\"\n        Sum of the split counts multiplied by the sample lab_split and field_split.\n\n        corrected_count = sum(split_count) * (100 / lab_split) * (100 / field_split)\n        \"\"\"\n        correctedCount: Float\n\n        \"Sum of the big rare count within the laboratory for this taxa. No other manipulation.\"\n        rawBigRareCount: Int\n    }\n\n    type SampleTaxa {\n        sampleId: Int\n        taxonomyId: Int\n        scientificName: String\n        taxaLevelId: Int\n        taxaLevel: String\n        organismCount: Int\n    }\n\n    type GeneralizedSampleTaxa {\n        sampleId: Int\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        lifeStageId: Int\n        lifeStage: String\n        lifeStageAbbreviation: String\n        bugSize: Float\n        rawCount: Float\n        correctedCount: Float\n        rawBigRareCount: Int\n    }\n\n    type TranslationSampleTaxa { \n        sampleId:Int \n        taxonomyId: Int\n        scientificName: String\n        aliasName: String\n        levelId: Int\n        levelName: String\n        rawCount: Float\n        correctedCount: Float\n        rawBigRareCount: Int\n    }\n\n    type RarefiedSampleTaxa {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        organismCount: Int\n    }\n\n    type SampleInfo {\n        sampleId:     Int\n        boxId:        Int\n        customerName:       String\n        customerAbbreviation: String\n        submittedBy:             String\n        boxState:          String\n        siteId:                 Int\n        siteName:               String\n        usState:                  String\n        siteLocation: String\n        siteLongitude: Float\n        siteLatitude: Float\n        visitId:                  String\n        sampleDate:               String\n        sampleTime:               String\n        sampleType:          String\n        sampleMethod:        String\n        habitat:              String\n        sampleLocation: String\n        sampleLongitude: Float\n        sampleLatitude: Float\n        area:                      Float\n        fieldSplit:               Float\n        fieldNotes:               String\n        labSplit:                 Float\n        jarCount:                 Int\n        qualitative:              Boolean\n        labNotes:                String\n        mesh:                    Int\n        createdDate:            String\n        updatedDate:            String\n        sampleDateChanged:       String\n        qaSampleId:            Int\n        metadata:                String\n    }\n\n    type BoxInfo {\n        boxId:                    Int\n                customerId:               Int\n                customerName:         String\n                customerAbbreviation: String\n                submitterId:              Int\n                submittedBy:              String\n                boxStateId:              Int\n                boxState:            String\n                boxReceivedDate:         String\n                processingCompleteDate:  String\n                projectedCompleteDate:   String\n                sampleCount:              Int\n                description:               String\n                metadata:                  String\n                measurements:              Boolean\n                sorterQa:                 Boolean\n                taxaQa:                   Boolean\n                createdDate:              String\n                updatedDate:              String\n    }\n\ntype SamplePredictorValue {\n    predictorId:                 Int\n                abbreviation:                 String\n                calculationScript:           String\n                isTemporal:                  Boolean\n                predictorMetadata:           String\n                predictorValue:              String\n                predictorValueUpdatedDate: String\n                status:                       String\n}\n\ntype PlanktonSample {\n    sampleId:        Int\n    diameter:        Float\n    subSampleCount:  Int\n    towLength:       Float\n    volume:          Float\n    aliquot:         Float\n    sizeInterval:    Float\n    towType:         String\n    updatedDate:     String\n\n}\n\ntype DriftSample {\n    sampleId:    Int\n    netArea:     Float\n    netDuration: Float\n    streamDepth: Float\n    netDepth:    Float\n    netVelocity: Float\n    updatedDate: String\n}\n\ntype FishSample {\n    sampleId: Int\n    taxonomyId: Int\n    scientificName: String\n    levelId: Int\n    levelName: String\n    fishLength: Float\n    fishMass: Float\n    updatedDate: String\n}\n\ntype MassSample {\n    sampleId: Int\n    typeId: Int\n    typeAbbreviation: String\n    typeName: String\n    methodId: Int\n    methodAbbreviation: String\n    methodName: String\n    mass: Float\n    updatedDate: String\n\n}\n\ntype ModelResult {\n    sampleId: Int\n    siteId:      Int\n    siteName:    String\n    modelId:     Int\n    modelName: String\n    modelVersion: String\n    modelResult: Float\n    condition: String\n    fixCount: Int\n    notes: String\n    metadata: String\n    createdDate: String\n    updatedDate: String\n}\n\ntype FishDiet {\n    sampleId:            Int\n    sampleDate:          String\n    siteId:              Int\n    siteName:            String\n    fishWeight:          Float\n    fishLength:          Float\n    fishTaxonomyId:     Int\n    fishScientificName: String\n    notes:                String\n    metadata:             String\n    organicWeight:       Float\n    inorganicWeight:     Float\n    otherWeight:         Float\n    createdDate:         String\n    updatedDate:         String\n    taxonomyId:          Int\n    scientificName:      String\n    lifeStageId:        Int\n    lifeStage: String\n    count:                Float\n    weight:               Float\n}\n\n\n    #  type Individual {\n    #     entityId: Int\n    #     firstName: String\n    #     lastName: String\n    #     initials: String\n    #     affilitationId: Int\n    #     affiliation: String\n    #     email: String\n    #     title: String\n    #     address1: String\n    #     address2: String\n    #     city: String\n    #     stateName: String\n    #     countryName: String\n    #     zipCode: String\n    #     phone: String\n    #     fax: String\n    # }\n\n    type Box {\n        boxId: Int\n        customerId: Int\n        customerName: String\n        submitterId: Int\n        submittedBy: String\n        boxState: String\n        boxReceivedDate: String\n        sampleCount: Int\n        processingCompleteDate: String\n        projectedCompleteDate: String\n    }\n\n    type Project {\n        projectId: Int\n        projectName: String\n        isPrivate: Boolean\n        contactId: Int\n        contactName: String\n        description: String\n        sampleCount: Int\n        modelCount: Int\n        createdDate: String\n        updatedDate: String\n    }\n\n    type Taxonomy {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        parentTaxonomyId: Int\n        parentScientificName: String\n        parentLevelId: Int\n        parentLevelName: String\n        notes: String\n        metadata: String\n        createdDate: String\n        updatedDate: String\n    }\n\n    type TaxonomyTree {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        parentId: Int\n    }\n\n    type Predictor {\n        predictorId: Int\n        predictorName: String\n        abbreviation: String\n        description: String\n        source: String\n        units: String\n        calculationScript: String\n        predictorTypeId: Int\n        predictorTypeName: String\n        isTemporal: Boolean\n        updatedDate: String\n        createdDate: String\n        modelCount: Int\n    }\n\n    type Model {\n        modelId: Int\n        modelName: String\n        abbreviation: String\n        isActive: Boolean\n        description: String\n        predictorCount: Int\n    }\n\n    type ModelInfo {\n        modelId: Int\n        modelName: String\n        abbreviation: String\n        modelType: String\n        translationId: Int\n        translation: String\n        extentDescription: String\n        platform: String\n        referenceSites: Int\n        groupCount: Int\n        minimumCount: Int\n        oeMean: Float\n        oeStdev: Float\n        taxonomicEffort: String\n        isActive: Boolean\n        fixedCount: Int\n        units: String\n        description: String\n        metadata: String\n        predictorCount: Int\n        createdDate: String\n        updatedDate: String\n        extent: String\n    }\n\n    type ModelCondition {\n        modelId: Int\n        conditionId: Int\n        condition: String\n        displayText: String\n        description: String\n    }\n\n    type Metric {\n        metricId: Int\n        metricName: String\n        metricTypeId: Int\n        typeName:  String\n        translationId: Int\n        translationName: String\n        formulaId: Int\n        formulaName: String\n        formulaCodeFunction: String\n        isStandardized: Boolean\n        perturbDirection: String\n        description: String\n        createdDate: String\n        updatedDate: String\n    }\n\n    \"\"\"\n    The value of a non-temporal predictor for a particular site.\n    \"\"\"\n    type SitePredictorValue {\n\n        \"The unique system generated identifier for the predictor.\"\n        predictorId: Int\n\n        \"The unique textual name for the predictor.\"\n        predictorName: String\n\n        \"The unique shorthand abbreviation for the predictor.\"\n        abbreviation: String\n\n        \"Long form information about the predictor.\"\n        description: String\n\n        \"The predictor type (e.g. metrics, atmosphere, geology, anthro).\"\n        predictorType: String\n\n        \"\"\"\n        The predictor value for this site. The value is always a string, even\n        if it represents an integer or floating point value.\n        \"\"\"\n        predictorValue: String\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"Optional name of the R function that performs the calculation for this predictor.\"\n        calculationScript: String\n    }\n\n    \"\"\"\n    Information about a model predictor.\n\n    Each predictor can be associated with multiple models. Predictors can also\n    be temporal, in which their values are associated with a particular sample,\n    or they can be non-temporal, in which case their values are associated with\n    sites.\n    \"\"\"\n    type ModelPredictor {\n\n        \"The unique system generated identifier for the predictor.\"\n        predictorId: Int\n\n        \"The unique textual name for the predictor.\"\n        predictorName: String\n\n        \"The unique shorthand abbreviation for the predictor.\"\n        abbreviation: String\n\n        \"The units in which the predictor values are stored.\"\n        units: String\n\n       \"The predictor type (e.g. metrics, atmosphere, geology, anthro).\"\n        predictorType: String\n\n        \"\"\"\n        Boolean representing whether the predictor varies over time or whether\n        there is just a single value for the site. True indicates that the predictor\n        is temporal and values are stored for each sample. False indicates that there\n        is only one predictor value for each site.\n        \"\"\"\n        isTemporal: Boolean\n\n        \"Long form information about the predictor.\"\n        description: String\n\n        \"Miscellaneou structured metadata in GeoJSON format.\"\n        metadata: String\n\n        \"The number of models that use the predictor\"\n        modelCount: Int\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"Optional name of the R function that performs the calculation for this predictor.\"\n        calculationScript: String\n\n    }\n\n    type Translation {\n        translationId: Int\n        translationName: String\n        description: String\n        isActive: Boolean\n        taxaCount: Int\n        createdDate: String\n        updatedDate: String\n    }\n\n    type TranslationTaxa {\n        translationId: Int\n        translationName: String\n        taxonomyId: Int\n        levelId: Int\n        levelName: String\n        originalScientificName: String\n        translationScientificName: String\n        isFinal: Boolean\n    }\n\n    type Attribute {\n        attributeId: Int\n        attributeName: String\n        attributeType: String\n        label: String\n        description: String\n        metadata: String\n        createdDate: String\n        updatedDate: String\n    }\n\n    type AttributeValue {\n        taxonomyId: Int\n        scientificName: String\n        levelId:  Int\n        levelName:  String\n        attributeName: String\n        attributeType: String\n        label: String\n        attributeValue: String\n    }\n\n    type MetricResult  {\n    sampleId:    Int\n    groupId:     Int\n    groupName:   String\n    metricId:    Int\n    metricName:  String\n    metricValue: String\n}\n\n\n    # Pagination Types\n  \n    type PaginatedModels {\n        records: [Model]\n        nextOffset: Int\n    }\n    type PaginatedSites {\n        records: [Site]\n        nextOffset: Int\n    }\n    type PaginatedSamples {\n        records: [Sample]\n        nextOffset: Int\n    }\n\n    type PaginatedBoxes {\n        records: [Box]\n        nextOffset: Int\n    }\n    type PaginatedProjects {\n        records: [Project]\n        nextOffset: Int\n    }\n    type PaginatedTaxonomies {\n        records: [Taxonomy]\n        nextOffset: Int\n    }\n\n    type PaginatedTaxonomyTree {\n        records: [TaxonomyTree]\n        nextOffset: Int\n    }\n\n    type PaginatedPredictors {\n        records: [Predictor]\n        nextOffset: Int\n    }\n    type PaginatedSitePredictorValues {\n        records: [SitePredictorValue]\n        nextOffset: Int\n    }\n\n    type PaginatedSamplePredictorValue {\n        records: [SamplePredictorValue]\n        nextOffset: Int\n    }\n\n    type PaginatedModelPredictors {\n        records: [ModelPredictor]\n        nextOffset: Int\n    }\n\n    type PaginatedTranslations {\n        records: [Translation]\n        nextOffset: Int\n    }\n\n    type PaginatedTranslationTaxa {\n        records: [TranslationTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedRawSampleTaxa {\n        records: [RawSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedSampleTaxa {\n        records: [SampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedGeneralizedSampleTaxa {\n        records: [GeneralizedSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedSampleTranslationTaxa {\n        records: [TranslationSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedRarefiedSampleTaxa {\n        records: [RarefiedSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedPlankton {\n        records: [PlanktonSample]\n        nextOffset: Int\n    }\n\n    type PaginatedDrift {\n        records: [DriftSample]\n        nextOffset: Int\n    }\n\n    type PaginatedFish {\n        records: [FishSample]\n        nextOffset: Int\n    }\n\n    type PaginatedMass {\n        records: [MassSample]\n        nextOffset: Int\n    }\n\n    type PaginatedAttributes {\n        records: [Attribute]\n        nextOffset: Int\n    }\n\n    type PaginatedAttributeValues {\n        records: [AttributeValue]\n        nextOffset: Int\n    }\n\n    type PaginatedModelConditions {\n        records: [ModelCondition]\n        nextOffset: Int\n    }\n\n    type PaginatedMetrics {\n        records: [Metric]\n        nextOffset: Int\n    }\n\n    type PaginatedMetricResult {\n        records: [MetricResult]\n        nextOffset: Int\n    }\n\n    type PaginatedModelResult {\n        records: [ModelResult]\n        nextOffset: Int\n    }\n\n    type PaginatedFishDiet {\n        records: [FishDiet]\n        nextOffset: Int\n    }\n"], ["\n    schema {\n        query: Query\n        mutation: Mutation\n    }\n\n    type Query {\n        # Get a project and associated metadata\n        auth: AuthParams\n\n        ####################################################################################################################################################################################\n        # Geo queries\n\n        \"Detailed information about a single site. Includes the point location and upstream catchment geometries as GeoJSON.\"\n        siteInfo(siteId: Int!): SiteInfo\n\n        \"Detailed information about a single model, including the number of predictors associated with the model.\"\n        modelInfo(modelId: Int!): ModelInfo\n\n        \"List of all model conditions (e.g. good, fair, poor) for a particular model\"\n        modelConditions(modelId: Int!): PaginatedModelConditions\n\n        ####################################################################################################################################################################################\n        # Sample queries\n\n        # \"Detailed information about a single sample, including information about the box and customer.\"\n        # sampleInfo(sampleId: Int!): SampleInfo\n\n        \"Detailed information about a single box, including information about the customer and number of samples associated with the box.\"\n        boxInfo(boxId: Int!): BoxInfo\n\n        \"List of all samples in the system, including high level information about the associated box and customer.\"\n        samples(limit: Int = ", ", offset: Int = 0, sampleIds: [Int], boxIds: [Int], projectIds: [Int], entityIds: [Int], siteIds: [Int], polygon: String, pointDistance: QueryDistance): PaginatedSamples\n\n        \"Summary information for all sites, including location coordinates and number of samples. Use the siteInfo query to get more detailed information about a single site.\"\n        sites(limit: Int = ", ", offset: Int = 0, usState: [String], sampleIds: [Int], boxIds: [Int], projectIds: [Int], entityIds: [Int], siteIds: [Int], polygon: String, pointDistance: QueryDistance): PaginatedSites\n        \n        # individuals(limit: Int, offset: Int): [Individual]\n        \"Summary information for all boxes, including the customer name and number of samples within the box. Use the boxInfo query to get more detailed information about a single box.\"\n        boxes(limit: Int = ", ", offset: Int = 0, boxIds: [Int], entityIds: [Int]): PaginatedBoxes\n\n        \"Summary information about all projects in the system. Use the projectInfo query to get more detailed about a single project.\"\n        projects(limit: Int = ", ", offset: Int = 0): PaginatedProjects\n\n        \"List of all predictors in the system. Includes summary information about how many models rely on each predictor.\"\n        predictors(modelId: Int, limit: Int = ", ", offset: Int = 0): PaginatedPredictors\n\n        \"List of all models in the system. Includes summary information about how many predictors are used by the model as well as the translation that might be required.\"\n        models(limit: Int = ", ", offset: Int = 0): PaginatedModels\n\n        \"List of predictor values at a single site. Site predictors are non-temporal. The value is common to all samples at the specific site.\"\n        sitePredictorValues(siteId: Int!, limit: Int = ", ", offset: Int = 0): PaginatedSitePredictorValues\n\n        \"List of all predictor values for a single sample. This includes both temporal and non-temporal predictors as well as their calculation status (current, missing, expired).\"\n        samplePredictorValues(sampleId: Int!): PaginatedSamplePredictorValue\n\n        \"List of predictors required by a single model.\"\n        modelPredictors(limit: Int = ", ", offset: Int = 0, modelId: Int!): PaginatedModelPredictors\n\n        modelResults(limit: Int = ", ", offset: Int = 0, sampleIds: [Int]!): PaginatedModelResult\n\n        ####################################################################################################################################################################################\n        # Taxonomy queries\n\n        \"List of all taxa in the system. Includes information about each level of the taxonomic hierarchy above each taxa.\"\n        taxonomy(limit: Int = ", ", offset: Int = 0): PaginatedTaxonomies\n\n        \"list all parents for a particular taxa\"\n        taxonomyTree(taxonomyId: Int!): PaginatedTaxonomyTree\n\n        \"List of all attributes in the system.\"\n        attributes(limit: Int = ", ", offset: Int = 0): PaginatedAttributes\n\n        \"List of all attributes that exist for a single taxa\"\n        taxaAttributes(taxonomyId: Int, limit: Int = ", ", offset: Int = 0): PaginatedAttributeValues\n  \n        \"List all the taxa within a specific translation (OTU)\"\n        translationTaxa(limit: Int = ", ", offset: Int = 0, translationId: Int!): PaginatedTranslationTaxa\n       \n        \"List of all translations in the system.\"\n        translations(limit: Int = ", ", offset: Int = 0): PaginatedTranslations\n\n        ####################################################################################################################################################################################\n        # Sample side table queries\n\n        \"List of all plankton samples in the system.\"\n        planktonSamples(limit: Int = ", ", offset: Int = 0): PaginatedPlankton\n\n        \"List of all drift samples in the system.\"\n        driftSamples(limit: Int = ", ", offset: Int = 0): PaginatedDrift\n\n        \"List of all fish samples in the system.\"\n        fishSamples(limit: Int = ", ", offset: Int = 0): PaginatedFish\n\n        \"List of all mass samples in the system.\"\n        massSamples(limit: Int = ", ", offset: Int = 0): PaginatedMass\n\n        \"List all fish diet samples in the system\"\n        fishDiet(limit: Int = ", ", offset: Int = 0, sampleIds: [Int]): PaginatedFishDiet\n\n        ####################################################################################################################################################################################\n        # Sample Taxa queries\n        \n        \"Sample organisms summed by taxonomy only. Includes both raw counts as well as counts corrected for lab and field split. Also includes both raw and corrected big rare counts.\"\n        sampleTaxaRaw(sampleIds: [Int], boxIds: [Int], projectIds: [Int]): PaginatedRawSampleTaxa\n\n        \"Sample organisms summed by taxonomy, life stage and bug size. Includes both raw counts as well as counts corrected for lab and field split. Also includes both raw and corrected big rare counts.\"\n        sampleTaxaGeneralized(sampleId: Int!): PaginatedGeneralizedSampleTaxa\n\n        \"Sample organisms converted to a translation (OTU). Rolls up counts to those taxa present in the translation and omits any organisms that don't roll up to a taxa in the translation.\"\n        sampleTaxaTranslation(sampleId: Int!, translationId: Int!): PaginatedSampleTranslationTaxa\n\n        # \"Sample organisms in their original taxonomic designation but rarefied to the specified fixed count.\"\n        # sampleTaxaRarefied(sampleId: Int!, fixedCount: Int!): PaginatedRarefiedSampleTaxa\n\n        \"Sample organisms converted to the translation (OTU) and then rarefied to the specified fixed count.\"\n        sampleTaxaTranslationRarefied(sampleId: Int!, translationId: Int!, fixedCount:Int!):PaginatedRarefiedSampleTaxa\n\n        \"Sample organisms within distance (meters) of a point (decimal degrees)\"\n        pointTaxaRaw(longitude: Float!, latitude: Float!, distance: Float!): PaginatedRawSampleTaxa\n   \n        \"Sample organisms within a polygon\"\n        polygonTaxaRaw(polygon: String!): PaginatedRawSampleTaxa\n\n        ####################################################################################################################################################################################\n        # Metric queries\n\n        metrics(limit: Int = ", ", offset: Int = 0): PaginatedMetrics\n\n        sampleMetrics(sampleIds: [Int], boxIds: [Int], projectIds: [Int], translationId: Int!, fixedCount: Int!): PaginatedMetricResult\n    }\n\n    # this schema allows the following mutation:\n    type Mutation {\n        \"Store a non-temporal predictor value for a specific site. See setSamplePredictorValue if you want to store a temporal predictor value associated with a particular sample.\"\n        setSitePredictorValue(siteId: Int!, predictorId: Int!, value:String!): Int\n\n        \"Store a temporal predictor value for a specific sample. Set setSitePredictorValue if you want to store a temporal predictor value associated with a particular site.\"\n        setSamplePredictorValue(sampleId: Int!, predictorId: Int!, value: String!): Int\n\n        \"Store the upstream catchment polygon for a specific site. The catchment polygon must be a valid, non-empty GeoJSON polygon that partially or entirely intersects with the United States.\"\n        setSiteCatchment(siteId: Int!, catchment: String!): Int\n\n        \"Create a new translation. The name is mandatory and cannot be an empty string. The description is optional.\"\n        createTranslation(translationName: String!, description: String): Int\n\n        \"Add or update a taxa associated with a translation\"\n        setTranslationTaxa(translationId: Int!, taxonomyId: Int!, alias:String, isFinal: Boolean): Int\n\n        \"Permanently remove a taxa from a translation\"\n        deleteTranslationTaxa(translationId: Int!, taxonomyId: Int!): Int\n  \n        \"Update information related to a specific taxa. Change its scientific name, move its level or change its parent\"\n        setTaxonomy(taxonomyId: Int!, scientificName: String!, levelId: Int!, parentId: Int!, author: String, year:String, notes: String, metadata:String): Int\n\n        createProject(projectName: String!, isPrivate: Boolean, description: String, metadata: String, contactId: Int): Int\n\n        addProjectSamples(projectId: Int!, sampleIds: [Int]): Int\n\n        addProjectBoxes(projectId: Int!, boxIds: [Int]): Int\n\n        removeProjectSamples(projectId: Int!, sampleIds:[Int]): Int\n\n        deleteProject(projectId: Int!): Int\n    }\n\n    input QueryDistance {\n        latitude: Float!\n        longitude: Float!\n        distance: Float!\n    }\n\n    type AuthParams {\n        loggedIn: Boolean\n        userPool: String\n        clientId: String\n        region: String\n        domain: String\n    }\n\n    type Sample {          \n        sampleId: Int\n        boxId: Int\n        customerName: String\n        customerAbbreviation: String\n        submittedBy: String\n        boxState: String\n        siteId: Int\n        siteName: String\n        usState: String\n        siteLocation: String\n        siteLongitude: Float\n        siteLatitude: Float\n        visitId: String\n        customerSiteCode: String\n        sampleDate: String\n        sampleTime: String\n        sampleType: String\n        sampleMethod: String\n        habitat: String\n        sampleLocation: String\n        sampleLongitude: Float\n        sampleLatitude: Float\n        area: Float\n        fieldSplit: Float\n        fieldNotes: String\n        labSplit: Float\n        jarCount: Int\n        qualitative: Boolean\n        labNotes: String\n        mesh: Int\n        createdDate: String\n        updatedDate: String\n        sampleDateChanged: String\n        qaSampleId: Int\n        metadata: String\n    }\n\n    type Site {\n        siteId: Int\n        siteName: String\n        system: String\n        ecosystem: String\n        longitude: Float\n        latitude: Float\n        usState: String\n        waterbodyType: String\n        waterbodyCode: String\n        waterbodyName: String\n        createdDate: String\n        updatedDate: String\n        hasCatchment: Boolean\n    }\n\n\"\"\"\nDetailed information about a single NAMC site.\n\nThis query includes the point and catchment geometries for the site.\nIt also includes the number of samples available at a particular site.\n\nMore succinct information is available for all sites using the\nsites API endpoint.\n\"\"\"\n    type SiteInfo {\n        \n        \"Unique database generated integer that uniquely identifies each site\"\n        siteId: Int\n\n        \"Unique text identifier for each site\"\n        siteName: String\n        \n        \"The ecological system (e.g. lake, pond, reservoir) in which the site is located.\"\n        system: String\n\n        \"The ecosystem in which the site is located.\"\n        ecosystem: String\n\n        \"GeoJSON point location of the site in [EPSG:4326](https://epsg.io/4326) spatial reference.\"\n        location: String\n\n        \"Longtidue of the site location in decimal degrees.\"\n        longitude: Float\n\n        \"Latitude of the site location in decimal degrees.\"\n        latitude: Float\n\n        \"US State in which the site is located.\"\n        usState: String\n\n        \"\"\"\n        If the site has a waterbody code, then the waterbody type identifies the system that\n        this identifier pertains to. The waterbody type might be NHDPlus 1:100,000 or \n        NHDPlusHR 1:24,000 etc.\n        \"\"\"\n        waterbodyType: String\n\n        \"\"\"\n        The identifier of the waterbody on which this site occurs. Can be null. If a \n        waterbody code exists, then the waterbodyType can be used to determine which\n        system the code belongs to, such as NHDPlus or NHDPlusHR.\n        \"\"\"\n        waterbodyCode: String\n\n        \"The string name of the waterbody on which the site occurs. Typicall this is the stream name.\"\n        waterbodyName: String\n\n        \"The latest date and time that either the site location (point) or catchment (polygon) were changed.\"\n        geographyChanged: String\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"GeoJSON polygon of the upstream area that drains into this site in [EPSG:4326](https://epsg.io/4326) spatial reference.\"\n        catchment: String\n\n        \"The number of samples that are available for this site.\"\n        sampleCount: Int\n    }\n\n    \"\"\"\"\n    Raw summary of organisms for a single sample. The data are returned with their original\n    laboratory taxonomic identification.\n    \"\"\"\n    type RawSampleTaxa {\n\n        \"The sample to which the taxa belong\"\n        sampleId: Int\n\n        \"The taxa identified within the laboratory.\"\n        taxonomyId: Int\n        \"The name of the taxa identified with the laboratory.\"\n        scientificName: String\n        \"The taxonomic level of the taxa identified within the laboratory.\"\n        levelId: Int\n        \"The taxonomic level of the taxa identified within the laboratory.\"\n        levelName: String\n        \"Sum of the split_counts recorded within the laboratory for this taxa. No other manipulation.\"\n        rawCount: Float\n        \n        \"\"\"\n        Sum of the split counts multiplied by the sample lab_split and field_split.\n\n        corrected_count = sum(split_count) * (100 / lab_split) * (100 / field_split)\n        \"\"\"\n        correctedCount: Float\n\n        \"Sum of the big rare count within the laboratory for this taxa. No other manipulation.\"\n        rawBigRareCount: Int\n    }\n\n    type SampleTaxa {\n        sampleId: Int\n        taxonomyId: Int\n        scientificName: String\n        taxaLevelId: Int\n        taxaLevel: String\n        organismCount: Int\n    }\n\n    type GeneralizedSampleTaxa {\n        sampleId: Int\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        lifeStageId: Int\n        lifeStage: String\n        lifeStageAbbreviation: String\n        bugSize: Float\n        rawCount: Float\n        correctedCount: Float\n        rawBigRareCount: Int\n    }\n\n    type TranslationSampleTaxa { \n        sampleId:Int \n        taxonomyId: Int\n        scientificName: String\n        aliasName: String\n        levelId: Int\n        levelName: String\n        rawCount: Float\n        correctedCount: Float\n        rawBigRareCount: Int\n    }\n\n    type RarefiedSampleTaxa {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        organismCount: Int\n    }\n\n    type SampleInfo {\n        sampleId:     Int\n        boxId:        Int\n        customerName:       String\n        customerAbbreviation: String\n        submittedBy:             String\n        boxState:          String\n        siteId:                 Int\n        siteName:               String\n        usState:                  String\n        siteLocation: String\n        siteLongitude: Float\n        siteLatitude: Float\n        visitId:                  String\n        sampleDate:               String\n        sampleTime:               String\n        sampleType:          String\n        sampleMethod:        String\n        habitat:              String\n        sampleLocation: String\n        sampleLongitude: Float\n        sampleLatitude: Float\n        area:                      Float\n        fieldSplit:               Float\n        fieldNotes:               String\n        labSplit:                 Float\n        jarCount:                 Int\n        qualitative:              Boolean\n        labNotes:                String\n        mesh:                    Int\n        createdDate:            String\n        updatedDate:            String\n        sampleDateChanged:       String\n        qaSampleId:            Int\n        metadata:                String\n    }\n\n    type BoxInfo {\n        boxId:                    Int\n                customerId:               Int\n                customerName:         String\n                customerAbbreviation: String\n                submitterId:              Int\n                submittedBy:              String\n                boxStateId:              Int\n                boxState:            String\n                boxReceivedDate:         String\n                processingCompleteDate:  String\n                projectedCompleteDate:   String\n                sampleCount:              Int\n                description:               String\n                metadata:                  String\n                measurements:              Boolean\n                sorterQa:                 Boolean\n                taxaQa:                   Boolean\n                createdDate:              String\n                updatedDate:              String\n    }\n\ntype SamplePredictorValue {\n    predictorId:                 Int\n                abbreviation:                 String\n                calculationScript:           String\n                isTemporal:                  Boolean\n                predictorMetadata:           String\n                predictorValue:              String\n                predictorValueUpdatedDate: String\n                status:                       String\n}\n\ntype PlanktonSample {\n    sampleId:        Int\n    diameter:        Float\n    subSampleCount:  Int\n    towLength:       Float\n    volume:          Float\n    aliquot:         Float\n    sizeInterval:    Float\n    towType:         String\n    updatedDate:     String\n\n}\n\ntype DriftSample {\n    sampleId:    Int\n    netArea:     Float\n    netDuration: Float\n    streamDepth: Float\n    netDepth:    Float\n    netVelocity: Float\n    updatedDate: String\n}\n\ntype FishSample {\n    sampleId: Int\n    taxonomyId: Int\n    scientificName: String\n    levelId: Int\n    levelName: String\n    fishLength: Float\n    fishMass: Float\n    updatedDate: String\n}\n\ntype MassSample {\n    sampleId: Int\n    typeId: Int\n    typeAbbreviation: String\n    typeName: String\n    methodId: Int\n    methodAbbreviation: String\n    methodName: String\n    mass: Float\n    updatedDate: String\n\n}\n\ntype ModelResult {\n    sampleId: Int\n    siteId:      Int\n    siteName:    String\n    modelId:     Int\n    modelName: String\n    modelVersion: String\n    modelResult: Float\n    condition: String\n    fixCount: Int\n    notes: String\n    metadata: String\n    createdDate: String\n    updatedDate: String\n}\n\ntype FishDiet {\n    sampleId:            Int\n    sampleDate:          String\n    siteId:              Int\n    siteName:            String\n    fishWeight:          Float\n    fishLength:          Float\n    fishTaxonomyId:     Int\n    fishScientificName: String\n    notes:                String\n    metadata:             String\n    organicWeight:       Float\n    inorganicWeight:     Float\n    otherWeight:         Float\n    createdDate:         String\n    updatedDate:         String\n    taxonomyId:          Int\n    scientificName:      String\n    lifeStageId:        Int\n    lifeStage: String\n    count:                Float\n    weight:               Float\n}\n\n\n    #  type Individual {\n    #     entityId: Int\n    #     firstName: String\n    #     lastName: String\n    #     initials: String\n    #     affilitationId: Int\n    #     affiliation: String\n    #     email: String\n    #     title: String\n    #     address1: String\n    #     address2: String\n    #     city: String\n    #     stateName: String\n    #     countryName: String\n    #     zipCode: String\n    #     phone: String\n    #     fax: String\n    # }\n\n    type Box {\n        boxId: Int\n        customerId: Int\n        customerName: String\n        submitterId: Int\n        submittedBy: String\n        boxState: String\n        boxReceivedDate: String\n        sampleCount: Int\n        processingCompleteDate: String\n        projectedCompleteDate: String\n    }\n\n    type Project {\n        projectId: Int\n        projectName: String\n        isPrivate: Boolean\n        contactId: Int\n        contactName: String\n        description: String\n        sampleCount: Int\n        modelCount: Int\n        createdDate: String\n        updatedDate: String\n    }\n\n    type Taxonomy {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        parentTaxonomyId: Int\n        parentScientificName: String\n        parentLevelId: Int\n        parentLevelName: String\n        notes: String\n        metadata: String\n        createdDate: String\n        updatedDate: String\n    }\n\n    type TaxonomyTree {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        parentId: Int\n    }\n\n    type Predictor {\n        predictorId: Int\n        predictorName: String\n        abbreviation: String\n        description: String\n        source: String\n        units: String\n        calculationScript: String\n        predictorTypeId: Int\n        predictorTypeName: String\n        isTemporal: Boolean\n        updatedDate: String\n        createdDate: String\n        modelCount: Int\n    }\n\n    type Model {\n        modelId: Int\n        modelName: String\n        abbreviation: String\n        isActive: Boolean\n        description: String\n        predictorCount: Int\n    }\n\n    type ModelInfo {\n        modelId: Int\n        modelName: String\n        abbreviation: String\n        modelType: String\n        translationId: Int\n        translation: String\n        extentDescription: String\n        platform: String\n        referenceSites: Int\n        groupCount: Int\n        minimumCount: Int\n        oeMean: Float\n        oeStdev: Float\n        taxonomicEffort: String\n        isActive: Boolean\n        fixedCount: Int\n        units: String\n        description: String\n        metadata: String\n        predictorCount: Int\n        createdDate: String\n        updatedDate: String\n        extent: String\n    }\n\n    type ModelCondition {\n        modelId: Int\n        conditionId: Int\n        condition: String\n        displayText: String\n        description: String\n    }\n\n    type Metric {\n        metricId: Int\n        metricName: String\n        metricTypeId: Int\n        typeName:  String\n        translationId: Int\n        translationName: String\n        formulaId: Int\n        formulaName: String\n        formulaCodeFunction: String\n        isStandardized: Boolean\n        perturbDirection: String\n        description: String\n        createdDate: String\n        updatedDate: String\n    }\n\n    \"\"\"\n    The value of a non-temporal predictor for a particular site.\n    \"\"\"\n    type SitePredictorValue {\n\n        \"The unique system generated identifier for the predictor.\"\n        predictorId: Int\n\n        \"The unique textual name for the predictor.\"\n        predictorName: String\n\n        \"The unique shorthand abbreviation for the predictor.\"\n        abbreviation: String\n\n        \"Long form information about the predictor.\"\n        description: String\n\n        \"The predictor type (e.g. metrics, atmosphere, geology, anthro).\"\n        predictorType: String\n\n        \"\"\"\n        The predictor value for this site. The value is always a string, even\n        if it represents an integer or floating point value.\n        \"\"\"\n        predictorValue: String\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"Optional name of the R function that performs the calculation for this predictor.\"\n        calculationScript: String\n    }\n\n    \"\"\"\n    Information about a model predictor.\n\n    Each predictor can be associated with multiple models. Predictors can also\n    be temporal, in which their values are associated with a particular sample,\n    or they can be non-temporal, in which case their values are associated with\n    sites.\n    \"\"\"\n    type ModelPredictor {\n\n        \"The unique system generated identifier for the predictor.\"\n        predictorId: Int\n\n        \"The unique textual name for the predictor.\"\n        predictorName: String\n\n        \"The unique shorthand abbreviation for the predictor.\"\n        abbreviation: String\n\n        \"The units in which the predictor values are stored.\"\n        units: String\n\n       \"The predictor type (e.g. metrics, atmosphere, geology, anthro).\"\n        predictorType: String\n\n        \"\"\"\n        Boolean representing whether the predictor varies over time or whether\n        there is just a single value for the site. True indicates that the predictor\n        is temporal and values are stored for each sample. False indicates that there\n        is only one predictor value for each site.\n        \"\"\"\n        isTemporal: Boolean\n\n        \"Long form information about the predictor.\"\n        description: String\n\n        \"Miscellaneou structured metadata in GeoJSON format.\"\n        metadata: String\n\n        \"The number of models that use the predictor\"\n        modelCount: Int\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"Optional name of the R function that performs the calculation for this predictor.\"\n        calculationScript: String\n\n    }\n\n    type Translation {\n        translationId: Int\n        translationName: String\n        description: String\n        isActive: Boolean\n        taxaCount: Int\n        createdDate: String\n        updatedDate: String\n    }\n\n    type TranslationTaxa {\n        translationId: Int\n        translationName: String\n        taxonomyId: Int\n        levelId: Int\n        levelName: String\n        originalScientificName: String\n        translationScientificName: String\n        isFinal: Boolean\n    }\n\n    type Attribute {\n        attributeId: Int\n        attributeName: String\n        attributeType: String\n        label: String\n        description: String\n        metadata: String\n        createdDate: String\n        updatedDate: String\n    }\n\n    type AttributeValue {\n        taxonomyId: Int\n        scientificName: String\n        levelId:  Int\n        levelName:  String\n        attributeName: String\n        attributeType: String\n        label: String\n        attributeValue: String\n    }\n\n    type MetricResult  {\n    sampleId:    Int\n    groupId:     Int\n    groupName:   String\n    metricId:    Int\n    metricName:  String\n    metricValue: String\n}\n\n\n    # Pagination Types\n  \n    type PaginatedModels {\n        records: [Model]\n        nextOffset: Int\n    }\n    type PaginatedSites {\n        records: [Site]\n        nextOffset: Int\n    }\n    type PaginatedSamples {\n        records: [Sample]\n        nextOffset: Int\n    }\n\n    type PaginatedBoxes {\n        records: [Box]\n        nextOffset: Int\n    }\n    type PaginatedProjects {\n        records: [Project]\n        nextOffset: Int\n    }\n    type PaginatedTaxonomies {\n        records: [Taxonomy]\n        nextOffset: Int\n    }\n\n    type PaginatedTaxonomyTree {\n        records: [TaxonomyTree]\n        nextOffset: Int\n    }\n\n    type PaginatedPredictors {\n        records: [Predictor]\n        nextOffset: Int\n    }\n    type PaginatedSitePredictorValues {\n        records: [SitePredictorValue]\n        nextOffset: Int\n    }\n\n    type PaginatedSamplePredictorValue {\n        records: [SamplePredictorValue]\n        nextOffset: Int\n    }\n\n    type PaginatedModelPredictors {\n        records: [ModelPredictor]\n        nextOffset: Int\n    }\n\n    type PaginatedTranslations {\n        records: [Translation]\n        nextOffset: Int\n    }\n\n    type PaginatedTranslationTaxa {\n        records: [TranslationTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedRawSampleTaxa {\n        records: [RawSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedSampleTaxa {\n        records: [SampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedGeneralizedSampleTaxa {\n        records: [GeneralizedSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedSampleTranslationTaxa {\n        records: [TranslationSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedRarefiedSampleTaxa {\n        records: [RarefiedSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedPlankton {\n        records: [PlanktonSample]\n        nextOffset: Int\n    }\n\n    type PaginatedDrift {\n        records: [DriftSample]\n        nextOffset: Int\n    }\n\n    type PaginatedFish {\n        records: [FishSample]\n        nextOffset: Int\n    }\n\n    type PaginatedMass {\n        records: [MassSample]\n        nextOffset: Int\n    }\n\n    type PaginatedAttributes {\n        records: [Attribute]\n        nextOffset: Int\n    }\n\n    type PaginatedAttributeValues {\n        records: [AttributeValue]\n        nextOffset: Int\n    }\n\n    type PaginatedModelConditions {\n        records: [ModelCondition]\n        nextOffset: Int\n    }\n\n    type PaginatedMetrics {\n        records: [Metric]\n        nextOffset: Int\n    }\n\n    type PaginatedMetricResult {\n        records: [MetricResult]\n        nextOffset: Int\n    }\n\n    type PaginatedModelResult {\n        records: [ModelResult]\n        nextOffset: Int\n    }\n\n    type PaginatedFishDiet {\n        records: [FishDiet]\n        nextOffset: Int\n    }\n"])), exports.queryLimits.samples, exports.queryLimits.sites, exports.queryLimits.boxes, exports.queryLimits.projects, exports.queryLimits.predictors, exports.queryLimits.models, exports.queryLimits.sitePredictorValues, exports.queryLimits.modelPredictors, exports.queryLimits.modelResults, exports.queryLimits.taxonomy, exports.queryLimits.taxonomy, exports.queryLimits.taxonomy, exports.queryLimits.taxonomy, exports.queryLimits.translations, exports.queryLimits.samples, exports.queryLimits.samples, exports.queryLimits.samples, exports.queryLimits.samples, exports.queryLimits.samples, exports.queryLimits.metrics);
=======
var typeDefs = graphql_tag_1.default(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    schema {\n        query: Query\n        mutation: Mutation\n    }\n\n    type Query {\n        # Get a project and associated metadata\n        auth: AuthParams\n\n        ####################################################################################################################################################################################\n        # Geo queries\n\n        \"Detailed information about a single site. Includes the point location and upstream catchment geometries as GeoJSON.\"\n        siteInfo(siteId: Int!): SiteInfo\n\n        \"Detailed information about a single model, including the number of predictors associated with the model.\"\n        modelInfo(modelId: Int!): ModelInfo\n\n        \"List of all model conditions (e.g. good, fair, poor) for a particular model\"\n        modelConditions(modelId: Int!): PaginatedModelConditions\n\n        ####################################################################################################################################################################################\n        # Sample queries\n\n        # \"Detailed information about a single sample, including information about the box and customer.\"\n        # sampleInfo(sampleId: Int!): SampleInfo\n\n        \"Detailed information about a single box, including information about the customer and number of samples associated with the box.\"\n        boxInfo(boxId: Int!): BoxInfo\n\n        \"List of all samples in the system, including high level information about the associated box and customer.\"\n        samples(limit: Int = ", ", offset: Int = 0, sampleIds: [Int], boxIds: [Int], projectIds: [Int], entityIds: [Int], siteIds: [Int], polygon: String, pointDistance: QueryDistance): PaginatedSamples\n\n        \"Summary information for all sites, including location coordinates and number of samples. Use the siteInfo query to get more detailed information about a single site.\"\n        sites(limit: Int = ", ", offset: Int = 0, usState: [String], sampleIds: [Int], boxIds: [Int], projectIds: [Int], entityIds: [Int], siteIds: [Int], polygon: String, pointDistance: QueryDistance): PaginatedSites\n        \n        # individuals(limit: Int, offset: Int): [Individual]\n        \"Summary information for all boxes, including the customer name and number of samples within the box. Use the boxInfo query to get more detailed information about a single box.\"\n        boxes(limit: Int = ", ", offset: Int = 0, boxIds: [Int], entityIds: [Int]): PaginatedBoxes\n\n        \"Summary information about all projects in the system. Use the projectInfo query to get more detailed about a single project.\"\n        projects(limit: Int = ", ", offset: Int = 0): PaginatedProjects\n\n        \"List of all predictors in the system. Includes summary information about how many models rely on each predictor.\"\n        predictors(modelId: Int, limit: Int = ", ", offset: Int = 0): PaginatedPredictors\n\n        \"List of all models in the system. Includes summary information about how many predictors are used by the model as well as the translation that might be required.\"\n        models(limit: Int = ", ", offset: Int = 0): PaginatedModels\n\n        \"List of predictor values at a single site. Site predictors are non-temporal. The value is common to all samples at the specific site.\"\n        sitePredictorValues(siteId: Int!, limit: Int = ", ", offset: Int = 0): PaginatedSitePredictorValues\n\n        \"List of all predictor values for a single sample. This includes both temporal and non-temporal predictors as well as their calculation status (current, missing, expired).\"\n        samplePredictorValues(sampleId: Int!): PaginatedSamplePredictorValue\n\n        \"List of predictors required by a single model.\"\n        modelPredictors(limit: Int = ", ", offset: Int = 0, modelId: Int!): PaginatedModelPredictors\n\n        modelResults(limit: Int = ", ", offset: Int = 0, sampleIds: [Int]!): PaginatedModelResult\n\n        ####################################################################################################################################################################################\n        # Taxonomy queries\n\n        \"List of all taxa in the system. Includes information about each level of the taxonomic hierarchy above each taxa.\"\n        taxonomy(limit: Int = ", ", offset: Int = 0): PaginatedTaxonomies\n\n        \"list all parents for a particular taxa\"\n        taxonomyTree(taxonomyId: Int!): PaginatedTaxonomyTree\n\n        \"List of all attributes in the system.\"\n        attributes(limit: Int = ", ", offset: Int = 0): PaginatedAttributes\n\n        \"List of all attributes that exist for a single taxa\"\n        taxaAttributes(taxonomyId: Int, limit: Int = ", ", offset: Int = 0): PaginatedAttributeValues\n  \n        \"List all the taxa within a specific translation (OTU)\"\n        translationTaxa(limit: Int = ", ", offset: Int = 0, translationId: Int!): PaginatedTranslationTaxa\n       \n        \"List of all translations in the system.\"\n        translations(limit: Int = ", ", offset: Int = 0): PaginatedTranslations\n\n        ####################################################################################################################################################################################\n        # Sample side table queries\n\n        \"List of all plankton samples in the system.\"\n        planktonSamples(limit: Int = ", ", offset: Int = 0): PaginatedPlankton\n\n        \"List of all drift samples in the system.\"\n        driftSamples(limit: Int = ", ", offset: Int = 0): PaginatedDrift\n\n        \"List of all fish samples in the system.\"\n        fishSamples(limit: Int = ", ", offset: Int = 0): PaginatedFish\n\n        \"List of all mass samples in the system.\"\n        massSamples(limit: Int = ", ", offset: Int = 0): PaginatedMass\n\n        \"List all fish diet samples in the system\"\n        fishDiet(limit: Int = ", ", offset: Int = 0, sampleIds: [Int]): PaginatedFishDiet\n\n        ####################################################################################################################################################################################\n        # Sample Taxa queries\n        \n        \"Sample organisms summed by taxonomy only. Includes both raw counts as well as counts corrected for lab and field split. Also includes both raw and corrected big rare counts.\"\n        sampleTaxaRaw(sampleIds: [Int], boxIds: [Int], projectIds: [Int]): PaginatedRawSampleTaxa\n\n        \"Sample organisms summed by taxonomy, life stage and bug size. Includes both raw counts as well as counts corrected for lab and field split. Also includes both raw and corrected big rare counts.\"\n        sampleTaxaGeneralized(sampleId: Int!): PaginatedGeneralizedSampleTaxa\n\n        \"Sample organisms converted to a translation (OTU). Rolls up counts to those taxa present in the translation and omits any organisms that don't roll up to a taxa in the translation.\"\n        sampleTaxaTranslation(sampleId: Int!, translationId: Int!): PaginatedSampleTranslationTaxa\n\n        # \"Sample organisms in their original taxonomic designation but rarefied to the specified fixed count.\"\n        # sampleTaxaRarefied(sampleId: Int!, fixedCount: Int!): PaginatedRarefiedSampleTaxa\n\n        \"Sample organisms converted to the translation (OTU) and then rarefied to the specified fixed count.\"\n        sampleTaxaTranslationRarefied(sampleId: Int!, translationId: Int!, fixedCount:Int!):PaginatedRarefiedSampleTaxa\n\n        \"Sample organisms within distance (meters) of a point (decimal degrees)\"\n        pointTaxaRaw(longitude: Float!, latitude: Float!, distance: Float!): PaginatedRawSampleTaxa\n   \n        \"Sample organisms within a polygon\"\n        polygonTaxaRaw(polygon: String!): PaginatedRawSampleTaxa\n\n        ####################################################################################################################################################################################\n        # Metric queries\n\n        metrics(limit: Int = ", ", offset: Int = 0): PaginatedMetrics\n\n        sampleMetrics(sampleIds: [Int], boxIds: [Int], projectIds: [Int], translationId: Int!, fixedCount: Int!): PaginatedMetricResult\n    }\n\n    # this schema allows the following mutation:\n    type Mutation {\n        \"Store a non-temporal predictor value for a specific site. See setSamplePredictorValue if you want to store a temporal predictor value associated with a particular sample.\"\n        setSitePredictorValue(siteId: Int!, predictorId: Int!, value:String!): Int\n\n        \"Store a temporal predictor value for a specific sample. Set setSitePredictorValue if you want to store a temporal predictor value associated with a particular site.\"\n        setSamplePredictorValue(sampleId: Int!, predictorId: Int!, value: String!): Int\n\n        \"Store the upstream catchment polygon for a specific site. The catchment polygon must be a valid, non-empty GeoJSON polygon that partially or entirely intersects with the United States.\"\n        setSiteCatchment(siteId: Int!, catchment: String!): Int\n\n        \"Create a new translation. The name is mandatory and cannot be an empty string. The description is optional.\"\n        createTranslation(translationName: String!, description: String): Int\n\n        \"Add or update a taxa associated with a translation\"\n        setTranslationTaxa(translationId: Int!, taxonomyId: Int!, alias:String, isFinal: Boolean): Int\n\n        \"Permanently remove a taxa from a translation\"\n        deleteTranslationTaxa(translationId: Int!, taxonomyId: Int!): Int\n  \n        \"Update information related to a specific taxa. Change its scientific name, move its level or change its parent\"\n        setTaxonomy(taxonomyId: Int!, scientificName: String!, levelId: Int!, parentId: Int!, author: String, year:String, notes: String, metadata:String): Int\n\n        createProject(projectName: String!, isPrivate: Boolean, description: String, metadata: String, contactId: Int): Int\n\n        addProjectSamples(projectId: Int!, sampleIds: [Int]): Int\n\n        addProjectBoxes(projectId: Int!, boxIds: [Int]): Int\n\n        removeProjectSamples(projectId: Int!, sampleIds:[Int]): Int\n\n        deleteProject(projectId: Int!): Int\n    }\n\n    input QueryDistance {\n        latitude: Float!\n        longitude: Float!\n        distance: Float!\n    }\n\n    type AuthParams {\n        loggedIn: Boolean\n        userPool: String\n        clientId: String\n        region: String\n        domain: String\n    }\n\n    type Sample {          \n        sampleId: Int\n        boxId: Int\n        customerName: String\n        customerAbbreviation: String\n        submittedBy: String\n        boxState: String\n        siteId: Int\n        siteName: String\n        usState: String\n        siteLocation: String\n        siteLongitude: Float\n        siteLatitude: Float\n        visitId: String\n        customerSiteCode: String\n        sampleDate: String\n        sampleTime: String\n        sampleType: String\n        sampleMethod: String\n        habitat: String\n        sampleLocation: String\n        sampleLongitude: Float\n        sampleLatitude: Float\n        area: Float\n        fieldSplit: Float\n        fieldNotes: String\n        labSplit: Float\n        jarCount: Int\n        qualitative: Boolean\n        labNotes: String\n        mesh: Int\n        createdDate: String\n        updatedDate: String\n        sampleDateChanged: String\n        qaSampleId: Int\n        metadata: String\n    }\n\n    type Site {\n        siteId: Int\n        siteName: String\n        system: String\n        ecosystem: String\n        longitude: Float\n        latitude: Float\n        usState: String\n        waterbodyType: String\n        waterbodyCode: String\n        waterbodyName: String\n        createdDate: String\n        updatedDate: String\n        hasCatchment: Boolean\n    }\n\n\"\"\"\nDetailed information about a single NAMC site.\n\nThis query includes the point and catchment geometries for the site.\nIt also includes the number of samples available at a particular site.\n\nMore succinct information is available for all sites using the\nsites API endpoint.\n\"\"\"\n    type SiteInfo {\n        \n        \"Unique database generated integer that uniquely identifies each site\"\n        siteId: Int\n\n        \"Unique text identifier for each site\"\n        siteName: String\n        \n        \"The ecological system (e.g. lake, pond, reservoir) in which the site is located.\"\n        system: String\n\n        \"The ecosystem in which the site is located.\"\n        ecosystem: String\n\n        \"GeoJSON point location of the site in [EPSG:4326](https://epsg.io/4326) spatial reference.\"\n        location: String\n\n        \"Longtidue of the site location in decimal degrees.\"\n        longitude: Float\n\n        \"Latitude of the site location in decimal degrees.\"\n        latitude: Float\n\n        \"US State in which the site is located.\"\n        usState: String\n\n        \"\"\"\n        If the site has a waterbody code, then the waterbody type identifies the system that\n        this identifier pertains to. The waterbody type might be NHDPlus 1:100,000 or \n        NHDPlusHR 1:24,000 etc.\n        \"\"\"\n        waterbodyType: String\n\n        \"\"\"\n        The identifier of the waterbody on which this site occurs. Can be null. If a \n        waterbody code exists, then the waterbodyType can be used to determine which\n        system the code belongs to, such as NHDPlus or NHDPlusHR.\n        \"\"\"\n        waterbodyCode: String\n\n        \"The string name of the waterbody on which the site occurs. Typicall this is the stream name.\"\n        waterbodyName: String\n\n        \"The latest date and time that either the site location (point) or catchment (polygon) were changed.\"\n        geographyChanged: String\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"GeoJSON polygon of the upstream area that drains into this site in [EPSG:4326](https://epsg.io/4326) spatial reference.\"\n        catchment: String\n\n        \"The number of samples that are available for this site.\"\n        sampleCount: Int\n    }\n\n    \"\"\"\"\n    Raw summary of organisms for a single sample. The data are returned with their original\n    laboratory taxonomic identification.\n    \"\"\"\n    type RawSampleTaxa {\n\n        \"The sample to which the taxa belong\"\n        sampleId: Int\n\n        \"The taxa identified within the laboratory.\"\n        taxonomyId: Int\n        \"The name of the taxa identified with the laboratory.\"\n        scientificName: String\n        \"The taxonomic level of the taxa identified within the laboratory.\"\n        levelId: Int\n        \"The taxonomic level of the taxa identified within the laboratory.\"\n        levelName: String\n        \"Abundance for the specified taxa and lifestage\"\n        abundance: Float\n    }\n\n    type SampleTaxa {\n        sampleId: Int\n        taxonomyId: Int\n        scientificName: String\n        taxaLevelId: Int\n        taxaLevel: String\n        organismCount: Int\n    }\n\n    type GeneralizedSampleTaxa {\n        sampleId: Int\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        lifeStageId: Int\n        lifeStage: String\n        lifeStageAbbreviation: String\n        bugSize: Float\n        rawCount: Float\n        correctedCount: Float\n        rawBigRareCount: Int\n    }\n\n    type TranslationSampleTaxa { \n        sampleId:Int \n        taxonomyId: Int\n        scientificName: String\n        aliasName: String\n        levelId: Int\n        levelName: String\n        rawCount: Float\n        correctedCount: Float\n        rawBigRareCount: Int\n    }\n\n    type RarefiedSampleTaxa {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        organismCount: Int\n    }\n\n    type SampleInfo {\n        sampleId:     Int\n        boxId:        Int\n        customerName:       String\n        customerAbbreviation: String\n        submittedBy:             String\n        boxState:          String\n        siteId:                 Int\n        siteName:               String\n        usState:                  String\n        siteLocation: String\n        siteLongitude: Float\n        siteLatitude: Float\n        visitId:                  String\n        sampleDate:               String\n        sampleTime:               String\n        sampleType:          String\n        sampleMethod:        String\n        habitat:              String\n        sampleLocation: String\n        sampleLongitude: Float\n        sampleLatitude: Float\n        area:                      Float\n        fieldSplit:               Float\n        fieldNotes:               String\n        labSplit:                 Float\n        jarCount:                 Int\n        qualitative:              Boolean\n        labNotes:                String\n        mesh:                    Int\n        createdDate:            String\n        updatedDate:            String\n        sampleDateChanged:       String\n        qaSampleId:            Int\n        metadata:                String\n    }\n\n    type BoxInfo {\n        boxId:                    Int\n                customerId:               Int\n                customerName:         String\n                customerAbbreviation: String\n                submitterId:              Int\n                submittedBy:              String\n                boxStateId:              Int\n                boxState:            String\n                boxReceivedDate:         String\n                processingCompleteDate:  String\n                projectedCompleteDate:   String\n                sampleCount:              Int\n                description:               String\n                metadata:                  String\n                measurements:              Boolean\n                sorterQa:                 Boolean\n                taxaQa:                   Boolean\n                createdDate:              String\n                updatedDate:              String\n    }\n\ntype SamplePredictorValue {\n    predictorId:                 Int\n                abbreviation:                 String\n                calculationScript:           String\n                isTemporal:                  Boolean\n                predictorMetadata:           String\n                predictorValue:              String\n                predictorValueUpdatedDate: String\n                status:                       String\n}\n\ntype PlanktonSample {\n    sampleId:        Int\n    diameter:        Float\n    subSampleCount:  Int\n    towLength:       Float\n    volume:          Float\n    aliquot:         Float\n    sizeInterval:    Float\n    towType:         String\n    updatedDate:     String\n\n}\n\ntype DriftSample {\n    sampleId:    Int\n    netArea:     Float\n    netDuration: Float\n    streamDepth: Float\n    netDepth:    Float\n    netVelocity: Float\n    updatedDate: String\n}\n\ntype FishSample {\n    sampleId: Int\n    taxonomyId: Int\n    scientificName: String\n    levelId: Int\n    levelName: String\n    fishLength: Float\n    fishMass: Float\n    updatedDate: String\n}\n\ntype MassSample {\n    sampleId: Int\n    typeId: Int\n    typeAbbreviation: String\n    typeName: String\n    methodId: Int\n    methodAbbreviation: String\n    methodName: String\n    mass: Float\n    updatedDate: String\n\n}\n\ntype ModelResult {\n    sampleId: Int\n    siteId:      Int\n    siteName:    String\n    modelId:     Int\n    modelName: String\n    modelVersion: String\n    modelResult: Float\n    condition: String\n    fixCount: Int\n    notes: String\n    metadata: String\n    createdDate: String\n    updatedDate: String\n}\n\ntype FishDiet {\n    sampleId:            Int\n    sampleDate:          String\n    siteId:              Int\n    siteName:            String\n    fishWeight:          Float\n    fishLength:          Float\n    fishTaxonomyId:     Int\n    fishScientificName: String\n    notes:                String\n    metadata:             String\n    organicWeight:       Float\n    inorganicWeight:     Float\n    otherWeight:         Float\n    createdDate:         String\n    updatedDate:         String\n    taxonomyId:          Int\n    scientificName:      String\n    lifeStageId:        Int\n    lifeStage: String\n    count:                Float\n    weight:               Float\n}\n\n\n    #  type Individual {\n    #     entityId: Int\n    #     firstName: String\n    #     lastName: String\n    #     initials: String\n    #     affilitationId: Int\n    #     affiliation: String\n    #     email: String\n    #     title: String\n    #     address1: String\n    #     address2: String\n    #     city: String\n    #     stateName: String\n    #     countryName: String\n    #     zipCode: String\n    #     phone: String\n    #     fax: String\n    # }\n\n    type Box {\n        boxId: Int\n        customerId: Int\n        customerName: String\n        submitterId: Int\n        submittedBy: String\n        boxState: String\n        boxReceivedDate: String\n        sampleCount: Int\n        processingCompleteDate: String\n        projectedCompleteDate: String\n    }\n\n    type Project {\n        projectId: Int\n        projectName: String\n        projectType: String\n        isPrivate: Boolean\n        contactId: Int\n        contactName: String\n        description: String\n        sampleCount: Int\n        modelCount: Int\n        createdDate: String\n        updatedDate: String\n    }\n\n    type Taxonomy {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        parentTaxonomyId: Int\n        parentScientificName: String\n        parentLevelId: Int\n        parentLevelName: String\n        notes: String\n        metadata: String\n        createdDate: String\n        updatedDate: String\n    }\n\n    type TaxonomyTree {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        parentId: Int\n    }\n\n    type Predictor {\n        predictorId: Int\n        predictorName: String\n        abbreviation: String\n        description: String\n        source: String\n        units: String\n        calculationScript: String\n        predictorTypeId: Int\n        predictorTypeName: String\n        isTemporal: Boolean\n        updatedDate: String\n        createdDate: String\n        modelCount: Int\n    }\n\n    type Model {\n        modelId: Int\n        modelName: String\n        abbreviation: String\n        isActive: Boolean\n        description: String\n        predictorCount: Int\n    }\n\n    type ModelInfo {\n        modelId: Int\n        modelName: String\n        abbreviation: String\n        modelType: String\n        translationId: Int\n        translation: String\n        extentDescription: String\n        platform: String\n        referenceSites: Int\n        groupCount: Int\n        minimumCount: Int\n        oeMean: Float\n        oeStdev: Float\n        taxonomicEffort: String\n        isActive: Boolean\n        fixedCount: Int\n        units: String\n        description: String\n        metadata: String\n        predictorCount: Int\n        createdDate: String\n        updatedDate: String\n        extent: String\n    }\n\n    type ModelCondition {\n        modelId: Int\n        conditionId: Int\n        condition: String\n        displayText: String\n        description: String\n    }\n\n    type Metric {\n        metricId: Int\n        metricName: String\n        metricTypeId: Int\n        typeName:  String\n        translationId: Int\n        translationName: String\n        formulaId: Int\n        formulaName: String\n        formulaCodeFunction: String\n        isStandardized: Boolean\n        perturbDirection: String\n        description: String\n        createdDate: String\n        updatedDate: String\n    }\n\n    \"\"\"\n    The value of a non-temporal predictor for a particular site.\n    \"\"\"\n    type SitePredictorValue {\n\n        \"The unique system generated identifier for the predictor.\"\n        predictorId: Int\n\n        \"The unique textual name for the predictor.\"\n        predictorName: String\n\n        \"The unique shorthand abbreviation for the predictor.\"\n        abbreviation: String\n\n        \"Long form information about the predictor.\"\n        description: String\n\n        \"The predictor type (e.g. metrics, atmosphere, geology, anthro).\"\n        predictorType: String\n\n        \"\"\"\n        The predictor value for this site. The value is always a string, even\n        if it represents an integer or floating point value.\n        \"\"\"\n        predictorValue: String\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"Optional name of the R function that performs the calculation for this predictor.\"\n        calculationScript: String\n    }\n\n    \"\"\"\n    Information about a model predictor.\n\n    Each predictor can be associated with multiple models. Predictors can also\n    be temporal, in which their values are associated with a particular sample,\n    or they can be non-temporal, in which case their values are associated with\n    sites.\n    \"\"\"\n    type ModelPredictor {\n\n        \"The unique system generated identifier for the predictor.\"\n        predictorId: Int\n\n        \"The unique textual name for the predictor.\"\n        predictorName: String\n\n        \"The unique shorthand abbreviation for the predictor.\"\n        abbreviation: String\n\n        \"The units in which the predictor values are stored.\"\n        units: String\n\n       \"The predictor type (e.g. metrics, atmosphere, geology, anthro).\"\n        predictorType: String\n\n        \"\"\"\n        Boolean representing whether the predictor varies over time or whether\n        there is just a single value for the site. True indicates that the predictor\n        is temporal and values are stored for each sample. False indicates that there\n        is only one predictor value for each site.\n        \"\"\"\n        isTemporal: Boolean\n\n        \"Long form information about the predictor.\"\n        description: String\n\n        \"Miscellaneou structured metadata in GeoJSON format.\"\n        metadata: String\n\n        \"The number of models that use the predictor\"\n        modelCount: Int\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"Optional name of the R function that performs the calculation for this predictor.\"\n        calculationScript: String\n\n    }\n\n    type Translation {\n        translationId: Int\n        translationName: String\n        description: String\n        isActive: Boolean\n        taxaCount: Int\n        createdDate: String\n        updatedDate: String\n    }\n\n    type TranslationTaxa {\n        translationId: Int\n        translationName: String\n        taxonomyId: Int\n        levelId: Int\n        levelName: String\n        originalScientificName: String\n        translationScientificName: String\n        isFinal: Boolean\n    }\n\n    type Attribute {\n        attributeId: Int\n        attributeName: String\n        attributeType: String\n        label: String\n        description: String\n        metadata: String\n        createdDate: String\n        updatedDate: String\n    }\n\n    type AttributeValue {\n        taxonomyId: Int\n        scientificName: String\n        levelId:  Int\n        levelName:  String\n        attributeName: String\n        attributeType: String\n        label: String\n        attributeValue: String\n    }\n\n    type MetricResult  {\n    sampleId:    Int\n    groupId:     Int\n    groupName:   String\n    metricId:    Int\n    metricName:  String\n    metricValue: String\n}\n\n\n    # Pagination Types\n  \n    type PaginatedModels {\n        records: [Model]\n        nextOffset: Int\n    }\n    type PaginatedSites {\n        records: [Site]\n        nextOffset: Int\n    }\n    type PaginatedSamples {\n        records: [Sample]\n        nextOffset: Int\n    }\n\n    type PaginatedBoxes {\n        records: [Box]\n        nextOffset: Int\n    }\n    type PaginatedProjects {\n        records: [Project]\n        nextOffset: Int\n    }\n    type PaginatedTaxonomies {\n        records: [Taxonomy]\n        nextOffset: Int\n    }\n\n    type PaginatedTaxonomyTree {\n        records: [TaxonomyTree]\n        nextOffset: Int\n    }\n\n    type PaginatedPredictors {\n        records: [Predictor]\n        nextOffset: Int\n    }\n    type PaginatedSitePredictorValues {\n        records: [SitePredictorValue]\n        nextOffset: Int\n    }\n\n    type PaginatedSamplePredictorValue {\n        records: [SamplePredictorValue]\n        nextOffset: Int\n    }\n\n    type PaginatedModelPredictors {\n        records: [ModelPredictor]\n        nextOffset: Int\n    }\n\n    type PaginatedTranslations {\n        records: [Translation]\n        nextOffset: Int\n    }\n\n    type PaginatedTranslationTaxa {\n        records: [TranslationTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedRawSampleTaxa {\n        records: [RawSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedSampleTaxa {\n        records: [SampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedGeneralizedSampleTaxa {\n        records: [GeneralizedSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedSampleTranslationTaxa {\n        records: [TranslationSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedRarefiedSampleTaxa {\n        records: [RarefiedSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedPlankton {\n        records: [PlanktonSample]\n        nextOffset: Int\n    }\n\n    type PaginatedDrift {\n        records: [DriftSample]\n        nextOffset: Int\n    }\n\n    type PaginatedFish {\n        records: [FishSample]\n        nextOffset: Int\n    }\n\n    type PaginatedMass {\n        records: [MassSample]\n        nextOffset: Int\n    }\n\n    type PaginatedAttributes {\n        records: [Attribute]\n        nextOffset: Int\n    }\n\n    type PaginatedAttributeValues {\n        records: [AttributeValue]\n        nextOffset: Int\n    }\n\n    type PaginatedModelConditions {\n        records: [ModelCondition]\n        nextOffset: Int\n    }\n\n    type PaginatedMetrics {\n        records: [Metric]\n        nextOffset: Int\n    }\n\n    type PaginatedMetricResult {\n        records: [MetricResult]\n        nextOffset: Int\n    }\n\n    type PaginatedModelResult {\n        records: [ModelResult]\n        nextOffset: Int\n    }\n\n    type PaginatedFishDiet {\n        records: [FishDiet]\n        nextOffset: Int\n    }\n"], ["\n    schema {\n        query: Query\n        mutation: Mutation\n    }\n\n    type Query {\n        # Get a project and associated metadata\n        auth: AuthParams\n\n        ####################################################################################################################################################################################\n        # Geo queries\n\n        \"Detailed information about a single site. Includes the point location and upstream catchment geometries as GeoJSON.\"\n        siteInfo(siteId: Int!): SiteInfo\n\n        \"Detailed information about a single model, including the number of predictors associated with the model.\"\n        modelInfo(modelId: Int!): ModelInfo\n\n        \"List of all model conditions (e.g. good, fair, poor) for a particular model\"\n        modelConditions(modelId: Int!): PaginatedModelConditions\n\n        ####################################################################################################################################################################################\n        # Sample queries\n\n        # \"Detailed information about a single sample, including information about the box and customer.\"\n        # sampleInfo(sampleId: Int!): SampleInfo\n\n        \"Detailed information about a single box, including information about the customer and number of samples associated with the box.\"\n        boxInfo(boxId: Int!): BoxInfo\n\n        \"List of all samples in the system, including high level information about the associated box and customer.\"\n        samples(limit: Int = ", ", offset: Int = 0, sampleIds: [Int], boxIds: [Int], projectIds: [Int], entityIds: [Int], siteIds: [Int], polygon: String, pointDistance: QueryDistance): PaginatedSamples\n\n        \"Summary information for all sites, including location coordinates and number of samples. Use the siteInfo query to get more detailed information about a single site.\"\n        sites(limit: Int = ", ", offset: Int = 0, usState: [String], sampleIds: [Int], boxIds: [Int], projectIds: [Int], entityIds: [Int], siteIds: [Int], polygon: String, pointDistance: QueryDistance): PaginatedSites\n        \n        # individuals(limit: Int, offset: Int): [Individual]\n        \"Summary information for all boxes, including the customer name and number of samples within the box. Use the boxInfo query to get more detailed information about a single box.\"\n        boxes(limit: Int = ", ", offset: Int = 0, boxIds: [Int], entityIds: [Int]): PaginatedBoxes\n\n        \"Summary information about all projects in the system. Use the projectInfo query to get more detailed about a single project.\"\n        projects(limit: Int = ", ", offset: Int = 0): PaginatedProjects\n\n        \"List of all predictors in the system. Includes summary information about how many models rely on each predictor.\"\n        predictors(modelId: Int, limit: Int = ", ", offset: Int = 0): PaginatedPredictors\n\n        \"List of all models in the system. Includes summary information about how many predictors are used by the model as well as the translation that might be required.\"\n        models(limit: Int = ", ", offset: Int = 0): PaginatedModels\n\n        \"List of predictor values at a single site. Site predictors are non-temporal. The value is common to all samples at the specific site.\"\n        sitePredictorValues(siteId: Int!, limit: Int = ", ", offset: Int = 0): PaginatedSitePredictorValues\n\n        \"List of all predictor values for a single sample. This includes both temporal and non-temporal predictors as well as their calculation status (current, missing, expired).\"\n        samplePredictorValues(sampleId: Int!): PaginatedSamplePredictorValue\n\n        \"List of predictors required by a single model.\"\n        modelPredictors(limit: Int = ", ", offset: Int = 0, modelId: Int!): PaginatedModelPredictors\n\n        modelResults(limit: Int = ", ", offset: Int = 0, sampleIds: [Int]!): PaginatedModelResult\n\n        ####################################################################################################################################################################################\n        # Taxonomy queries\n\n        \"List of all taxa in the system. Includes information about each level of the taxonomic hierarchy above each taxa.\"\n        taxonomy(limit: Int = ", ", offset: Int = 0): PaginatedTaxonomies\n\n        \"list all parents for a particular taxa\"\n        taxonomyTree(taxonomyId: Int!): PaginatedTaxonomyTree\n\n        \"List of all attributes in the system.\"\n        attributes(limit: Int = ", ", offset: Int = 0): PaginatedAttributes\n\n        \"List of all attributes that exist for a single taxa\"\n        taxaAttributes(taxonomyId: Int, limit: Int = ", ", offset: Int = 0): PaginatedAttributeValues\n  \n        \"List all the taxa within a specific translation (OTU)\"\n        translationTaxa(limit: Int = ", ", offset: Int = 0, translationId: Int!): PaginatedTranslationTaxa\n       \n        \"List of all translations in the system.\"\n        translations(limit: Int = ", ", offset: Int = 0): PaginatedTranslations\n\n        ####################################################################################################################################################################################\n        # Sample side table queries\n\n        \"List of all plankton samples in the system.\"\n        planktonSamples(limit: Int = ", ", offset: Int = 0): PaginatedPlankton\n\n        \"List of all drift samples in the system.\"\n        driftSamples(limit: Int = ", ", offset: Int = 0): PaginatedDrift\n\n        \"List of all fish samples in the system.\"\n        fishSamples(limit: Int = ", ", offset: Int = 0): PaginatedFish\n\n        \"List of all mass samples in the system.\"\n        massSamples(limit: Int = ", ", offset: Int = 0): PaginatedMass\n\n        \"List all fish diet samples in the system\"\n        fishDiet(limit: Int = ", ", offset: Int = 0, sampleIds: [Int]): PaginatedFishDiet\n\n        ####################################################################################################################################################################################\n        # Sample Taxa queries\n        \n        \"Sample organisms summed by taxonomy only. Includes both raw counts as well as counts corrected for lab and field split. Also includes both raw and corrected big rare counts.\"\n        sampleTaxaRaw(sampleIds: [Int], boxIds: [Int], projectIds: [Int]): PaginatedRawSampleTaxa\n\n        \"Sample organisms summed by taxonomy, life stage and bug size. Includes both raw counts as well as counts corrected for lab and field split. Also includes both raw and corrected big rare counts.\"\n        sampleTaxaGeneralized(sampleId: Int!): PaginatedGeneralizedSampleTaxa\n\n        \"Sample organisms converted to a translation (OTU). Rolls up counts to those taxa present in the translation and omits any organisms that don't roll up to a taxa in the translation.\"\n        sampleTaxaTranslation(sampleId: Int!, translationId: Int!): PaginatedSampleTranslationTaxa\n\n        # \"Sample organisms in their original taxonomic designation but rarefied to the specified fixed count.\"\n        # sampleTaxaRarefied(sampleId: Int!, fixedCount: Int!): PaginatedRarefiedSampleTaxa\n\n        \"Sample organisms converted to the translation (OTU) and then rarefied to the specified fixed count.\"\n        sampleTaxaTranslationRarefied(sampleId: Int!, translationId: Int!, fixedCount:Int!):PaginatedRarefiedSampleTaxa\n\n        \"Sample organisms within distance (meters) of a point (decimal degrees)\"\n        pointTaxaRaw(longitude: Float!, latitude: Float!, distance: Float!): PaginatedRawSampleTaxa\n   \n        \"Sample organisms within a polygon\"\n        polygonTaxaRaw(polygon: String!): PaginatedRawSampleTaxa\n\n        ####################################################################################################################################################################################\n        # Metric queries\n\n        metrics(limit: Int = ", ", offset: Int = 0): PaginatedMetrics\n\n        sampleMetrics(sampleIds: [Int], boxIds: [Int], projectIds: [Int], translationId: Int!, fixedCount: Int!): PaginatedMetricResult\n    }\n\n    # this schema allows the following mutation:\n    type Mutation {\n        \"Store a non-temporal predictor value for a specific site. See setSamplePredictorValue if you want to store a temporal predictor value associated with a particular sample.\"\n        setSitePredictorValue(siteId: Int!, predictorId: Int!, value:String!): Int\n\n        \"Store a temporal predictor value for a specific sample. Set setSitePredictorValue if you want to store a temporal predictor value associated with a particular site.\"\n        setSamplePredictorValue(sampleId: Int!, predictorId: Int!, value: String!): Int\n\n        \"Store the upstream catchment polygon for a specific site. The catchment polygon must be a valid, non-empty GeoJSON polygon that partially or entirely intersects with the United States.\"\n        setSiteCatchment(siteId: Int!, catchment: String!): Int\n\n        \"Create a new translation. The name is mandatory and cannot be an empty string. The description is optional.\"\n        createTranslation(translationName: String!, description: String): Int\n\n        \"Add or update a taxa associated with a translation\"\n        setTranslationTaxa(translationId: Int!, taxonomyId: Int!, alias:String, isFinal: Boolean): Int\n\n        \"Permanently remove a taxa from a translation\"\n        deleteTranslationTaxa(translationId: Int!, taxonomyId: Int!): Int\n  \n        \"Update information related to a specific taxa. Change its scientific name, move its level or change its parent\"\n        setTaxonomy(taxonomyId: Int!, scientificName: String!, levelId: Int!, parentId: Int!, author: String, year:String, notes: String, metadata:String): Int\n\n        createProject(projectName: String!, isPrivate: Boolean, description: String, metadata: String, contactId: Int): Int\n\n        addProjectSamples(projectId: Int!, sampleIds: [Int]): Int\n\n        addProjectBoxes(projectId: Int!, boxIds: [Int]): Int\n\n        removeProjectSamples(projectId: Int!, sampleIds:[Int]): Int\n\n        deleteProject(projectId: Int!): Int\n    }\n\n    input QueryDistance {\n        latitude: Float!\n        longitude: Float!\n        distance: Float!\n    }\n\n    type AuthParams {\n        loggedIn: Boolean\n        userPool: String\n        clientId: String\n        region: String\n        domain: String\n    }\n\n    type Sample {          \n        sampleId: Int\n        boxId: Int\n        customerName: String\n        customerAbbreviation: String\n        submittedBy: String\n        boxState: String\n        siteId: Int\n        siteName: String\n        usState: String\n        siteLocation: String\n        siteLongitude: Float\n        siteLatitude: Float\n        visitId: String\n        customerSiteCode: String\n        sampleDate: String\n        sampleTime: String\n        sampleType: String\n        sampleMethod: String\n        habitat: String\n        sampleLocation: String\n        sampleLongitude: Float\n        sampleLatitude: Float\n        area: Float\n        fieldSplit: Float\n        fieldNotes: String\n        labSplit: Float\n        jarCount: Int\n        qualitative: Boolean\n        labNotes: String\n        mesh: Int\n        createdDate: String\n        updatedDate: String\n        sampleDateChanged: String\n        qaSampleId: Int\n        metadata: String\n    }\n\n    type Site {\n        siteId: Int\n        siteName: String\n        system: String\n        ecosystem: String\n        longitude: Float\n        latitude: Float\n        usState: String\n        waterbodyType: String\n        waterbodyCode: String\n        waterbodyName: String\n        createdDate: String\n        updatedDate: String\n        hasCatchment: Boolean\n    }\n\n\"\"\"\nDetailed information about a single NAMC site.\n\nThis query includes the point and catchment geometries for the site.\nIt also includes the number of samples available at a particular site.\n\nMore succinct information is available for all sites using the\nsites API endpoint.\n\"\"\"\n    type SiteInfo {\n        \n        \"Unique database generated integer that uniquely identifies each site\"\n        siteId: Int\n\n        \"Unique text identifier for each site\"\n        siteName: String\n        \n        \"The ecological system (e.g. lake, pond, reservoir) in which the site is located.\"\n        system: String\n\n        \"The ecosystem in which the site is located.\"\n        ecosystem: String\n\n        \"GeoJSON point location of the site in [EPSG:4326](https://epsg.io/4326) spatial reference.\"\n        location: String\n\n        \"Longtidue of the site location in decimal degrees.\"\n        longitude: Float\n\n        \"Latitude of the site location in decimal degrees.\"\n        latitude: Float\n\n        \"US State in which the site is located.\"\n        usState: String\n\n        \"\"\"\n        If the site has a waterbody code, then the waterbody type identifies the system that\n        this identifier pertains to. The waterbody type might be NHDPlus 1:100,000 or \n        NHDPlusHR 1:24,000 etc.\n        \"\"\"\n        waterbodyType: String\n\n        \"\"\"\n        The identifier of the waterbody on which this site occurs. Can be null. If a \n        waterbody code exists, then the waterbodyType can be used to determine which\n        system the code belongs to, such as NHDPlus or NHDPlusHR.\n        \"\"\"\n        waterbodyCode: String\n\n        \"The string name of the waterbody on which the site occurs. Typicall this is the stream name.\"\n        waterbodyName: String\n\n        \"The latest date and time that either the site location (point) or catchment (polygon) were changed.\"\n        geographyChanged: String\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"GeoJSON polygon of the upstream area that drains into this site in [EPSG:4326](https://epsg.io/4326) spatial reference.\"\n        catchment: String\n\n        \"The number of samples that are available for this site.\"\n        sampleCount: Int\n    }\n\n    \"\"\"\"\n    Raw summary of organisms for a single sample. The data are returned with their original\n    laboratory taxonomic identification.\n    \"\"\"\n    type RawSampleTaxa {\n\n        \"The sample to which the taxa belong\"\n        sampleId: Int\n\n        \"The taxa identified within the laboratory.\"\n        taxonomyId: Int\n        \"The name of the taxa identified with the laboratory.\"\n        scientificName: String\n        \"The taxonomic level of the taxa identified within the laboratory.\"\n        levelId: Int\n        \"The taxonomic level of the taxa identified within the laboratory.\"\n        levelName: String\n        \"Abundance for the specified taxa and lifestage\"\n        abundance: Float\n    }\n\n    type SampleTaxa {\n        sampleId: Int\n        taxonomyId: Int\n        scientificName: String\n        taxaLevelId: Int\n        taxaLevel: String\n        organismCount: Int\n    }\n\n    type GeneralizedSampleTaxa {\n        sampleId: Int\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        lifeStageId: Int\n        lifeStage: String\n        lifeStageAbbreviation: String\n        bugSize: Float\n        rawCount: Float\n        correctedCount: Float\n        rawBigRareCount: Int\n    }\n\n    type TranslationSampleTaxa { \n        sampleId:Int \n        taxonomyId: Int\n        scientificName: String\n        aliasName: String\n        levelId: Int\n        levelName: String\n        rawCount: Float\n        correctedCount: Float\n        rawBigRareCount: Int\n    }\n\n    type RarefiedSampleTaxa {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        organismCount: Int\n    }\n\n    type SampleInfo {\n        sampleId:     Int\n        boxId:        Int\n        customerName:       String\n        customerAbbreviation: String\n        submittedBy:             String\n        boxState:          String\n        siteId:                 Int\n        siteName:               String\n        usState:                  String\n        siteLocation: String\n        siteLongitude: Float\n        siteLatitude: Float\n        visitId:                  String\n        sampleDate:               String\n        sampleTime:               String\n        sampleType:          String\n        sampleMethod:        String\n        habitat:              String\n        sampleLocation: String\n        sampleLongitude: Float\n        sampleLatitude: Float\n        area:                      Float\n        fieldSplit:               Float\n        fieldNotes:               String\n        labSplit:                 Float\n        jarCount:                 Int\n        qualitative:              Boolean\n        labNotes:                String\n        mesh:                    Int\n        createdDate:            String\n        updatedDate:            String\n        sampleDateChanged:       String\n        qaSampleId:            Int\n        metadata:                String\n    }\n\n    type BoxInfo {\n        boxId:                    Int\n                customerId:               Int\n                customerName:         String\n                customerAbbreviation: String\n                submitterId:              Int\n                submittedBy:              String\n                boxStateId:              Int\n                boxState:            String\n                boxReceivedDate:         String\n                processingCompleteDate:  String\n                projectedCompleteDate:   String\n                sampleCount:              Int\n                description:               String\n                metadata:                  String\n                measurements:              Boolean\n                sorterQa:                 Boolean\n                taxaQa:                   Boolean\n                createdDate:              String\n                updatedDate:              String\n    }\n\ntype SamplePredictorValue {\n    predictorId:                 Int\n                abbreviation:                 String\n                calculationScript:           String\n                isTemporal:                  Boolean\n                predictorMetadata:           String\n                predictorValue:              String\n                predictorValueUpdatedDate: String\n                status:                       String\n}\n\ntype PlanktonSample {\n    sampleId:        Int\n    diameter:        Float\n    subSampleCount:  Int\n    towLength:       Float\n    volume:          Float\n    aliquot:         Float\n    sizeInterval:    Float\n    towType:         String\n    updatedDate:     String\n\n}\n\ntype DriftSample {\n    sampleId:    Int\n    netArea:     Float\n    netDuration: Float\n    streamDepth: Float\n    netDepth:    Float\n    netVelocity: Float\n    updatedDate: String\n}\n\ntype FishSample {\n    sampleId: Int\n    taxonomyId: Int\n    scientificName: String\n    levelId: Int\n    levelName: String\n    fishLength: Float\n    fishMass: Float\n    updatedDate: String\n}\n\ntype MassSample {\n    sampleId: Int\n    typeId: Int\n    typeAbbreviation: String\n    typeName: String\n    methodId: Int\n    methodAbbreviation: String\n    methodName: String\n    mass: Float\n    updatedDate: String\n\n}\n\ntype ModelResult {\n    sampleId: Int\n    siteId:      Int\n    siteName:    String\n    modelId:     Int\n    modelName: String\n    modelVersion: String\n    modelResult: Float\n    condition: String\n    fixCount: Int\n    notes: String\n    metadata: String\n    createdDate: String\n    updatedDate: String\n}\n\ntype FishDiet {\n    sampleId:            Int\n    sampleDate:          String\n    siteId:              Int\n    siteName:            String\n    fishWeight:          Float\n    fishLength:          Float\n    fishTaxonomyId:     Int\n    fishScientificName: String\n    notes:                String\n    metadata:             String\n    organicWeight:       Float\n    inorganicWeight:     Float\n    otherWeight:         Float\n    createdDate:         String\n    updatedDate:         String\n    taxonomyId:          Int\n    scientificName:      String\n    lifeStageId:        Int\n    lifeStage: String\n    count:                Float\n    weight:               Float\n}\n\n\n    #  type Individual {\n    #     entityId: Int\n    #     firstName: String\n    #     lastName: String\n    #     initials: String\n    #     affilitationId: Int\n    #     affiliation: String\n    #     email: String\n    #     title: String\n    #     address1: String\n    #     address2: String\n    #     city: String\n    #     stateName: String\n    #     countryName: String\n    #     zipCode: String\n    #     phone: String\n    #     fax: String\n    # }\n\n    type Box {\n        boxId: Int\n        customerId: Int\n        customerName: String\n        submitterId: Int\n        submittedBy: String\n        boxState: String\n        boxReceivedDate: String\n        sampleCount: Int\n        processingCompleteDate: String\n        projectedCompleteDate: String\n    }\n\n    type Project {\n        projectId: Int\n        projectName: String\n        projectType: String\n        isPrivate: Boolean\n        contactId: Int\n        contactName: String\n        description: String\n        sampleCount: Int\n        modelCount: Int\n        createdDate: String\n        updatedDate: String\n    }\n\n    type Taxonomy {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        parentTaxonomyId: Int\n        parentScientificName: String\n        parentLevelId: Int\n        parentLevelName: String\n        notes: String\n        metadata: String\n        createdDate: String\n        updatedDate: String\n    }\n\n    type TaxonomyTree {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        parentId: Int\n    }\n\n    type Predictor {\n        predictorId: Int\n        predictorName: String\n        abbreviation: String\n        description: String\n        source: String\n        units: String\n        calculationScript: String\n        predictorTypeId: Int\n        predictorTypeName: String\n        isTemporal: Boolean\n        updatedDate: String\n        createdDate: String\n        modelCount: Int\n    }\n\n    type Model {\n        modelId: Int\n        modelName: String\n        abbreviation: String\n        isActive: Boolean\n        description: String\n        predictorCount: Int\n    }\n\n    type ModelInfo {\n        modelId: Int\n        modelName: String\n        abbreviation: String\n        modelType: String\n        translationId: Int\n        translation: String\n        extentDescription: String\n        platform: String\n        referenceSites: Int\n        groupCount: Int\n        minimumCount: Int\n        oeMean: Float\n        oeStdev: Float\n        taxonomicEffort: String\n        isActive: Boolean\n        fixedCount: Int\n        units: String\n        description: String\n        metadata: String\n        predictorCount: Int\n        createdDate: String\n        updatedDate: String\n        extent: String\n    }\n\n    type ModelCondition {\n        modelId: Int\n        conditionId: Int\n        condition: String\n        displayText: String\n        description: String\n    }\n\n    type Metric {\n        metricId: Int\n        metricName: String\n        metricTypeId: Int\n        typeName:  String\n        translationId: Int\n        translationName: String\n        formulaId: Int\n        formulaName: String\n        formulaCodeFunction: String\n        isStandardized: Boolean\n        perturbDirection: String\n        description: String\n        createdDate: String\n        updatedDate: String\n    }\n\n    \"\"\"\n    The value of a non-temporal predictor for a particular site.\n    \"\"\"\n    type SitePredictorValue {\n\n        \"The unique system generated identifier for the predictor.\"\n        predictorId: Int\n\n        \"The unique textual name for the predictor.\"\n        predictorName: String\n\n        \"The unique shorthand abbreviation for the predictor.\"\n        abbreviation: String\n\n        \"Long form information about the predictor.\"\n        description: String\n\n        \"The predictor type (e.g. metrics, atmosphere, geology, anthro).\"\n        predictorType: String\n\n        \"\"\"\n        The predictor value for this site. The value is always a string, even\n        if it represents an integer or floating point value.\n        \"\"\"\n        predictorValue: String\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"Optional name of the R function that performs the calculation for this predictor.\"\n        calculationScript: String\n    }\n\n    \"\"\"\n    Information about a model predictor.\n\n    Each predictor can be associated with multiple models. Predictors can also\n    be temporal, in which their values are associated with a particular sample,\n    or they can be non-temporal, in which case their values are associated with\n    sites.\n    \"\"\"\n    type ModelPredictor {\n\n        \"The unique system generated identifier for the predictor.\"\n        predictorId: Int\n\n        \"The unique textual name for the predictor.\"\n        predictorName: String\n\n        \"The unique shorthand abbreviation for the predictor.\"\n        abbreviation: String\n\n        \"The units in which the predictor values are stored.\"\n        units: String\n\n       \"The predictor type (e.g. metrics, atmosphere, geology, anthro).\"\n        predictorType: String\n\n        \"\"\"\n        Boolean representing whether the predictor varies over time or whether\n        there is just a single value for the site. True indicates that the predictor\n        is temporal and values are stored for each sample. False indicates that there\n        is only one predictor value for each site.\n        \"\"\"\n        isTemporal: Boolean\n\n        \"Long form information about the predictor.\"\n        description: String\n\n        \"Miscellaneou structured metadata in GeoJSON format.\"\n        metadata: String\n\n        \"The number of models that use the predictor\"\n        modelCount: Int\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"Optional name of the R function that performs the calculation for this predictor.\"\n        calculationScript: String\n\n    }\n\n    type Translation {\n        translationId: Int\n        translationName: String\n        description: String\n        isActive: Boolean\n        taxaCount: Int\n        createdDate: String\n        updatedDate: String\n    }\n\n    type TranslationTaxa {\n        translationId: Int\n        translationName: String\n        taxonomyId: Int\n        levelId: Int\n        levelName: String\n        originalScientificName: String\n        translationScientificName: String\n        isFinal: Boolean\n    }\n\n    type Attribute {\n        attributeId: Int\n        attributeName: String\n        attributeType: String\n        label: String\n        description: String\n        metadata: String\n        createdDate: String\n        updatedDate: String\n    }\n\n    type AttributeValue {\n        taxonomyId: Int\n        scientificName: String\n        levelId:  Int\n        levelName:  String\n        attributeName: String\n        attributeType: String\n        label: String\n        attributeValue: String\n    }\n\n    type MetricResult  {\n    sampleId:    Int\n    groupId:     Int\n    groupName:   String\n    metricId:    Int\n    metricName:  String\n    metricValue: String\n}\n\n\n    # Pagination Types\n  \n    type PaginatedModels {\n        records: [Model]\n        nextOffset: Int\n    }\n    type PaginatedSites {\n        records: [Site]\n        nextOffset: Int\n    }\n    type PaginatedSamples {\n        records: [Sample]\n        nextOffset: Int\n    }\n\n    type PaginatedBoxes {\n        records: [Box]\n        nextOffset: Int\n    }\n    type PaginatedProjects {\n        records: [Project]\n        nextOffset: Int\n    }\n    type PaginatedTaxonomies {\n        records: [Taxonomy]\n        nextOffset: Int\n    }\n\n    type PaginatedTaxonomyTree {\n        records: [TaxonomyTree]\n        nextOffset: Int\n    }\n\n    type PaginatedPredictors {\n        records: [Predictor]\n        nextOffset: Int\n    }\n    type PaginatedSitePredictorValues {\n        records: [SitePredictorValue]\n        nextOffset: Int\n    }\n\n    type PaginatedSamplePredictorValue {\n        records: [SamplePredictorValue]\n        nextOffset: Int\n    }\n\n    type PaginatedModelPredictors {\n        records: [ModelPredictor]\n        nextOffset: Int\n    }\n\n    type PaginatedTranslations {\n        records: [Translation]\n        nextOffset: Int\n    }\n\n    type PaginatedTranslationTaxa {\n        records: [TranslationTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedRawSampleTaxa {\n        records: [RawSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedSampleTaxa {\n        records: [SampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedGeneralizedSampleTaxa {\n        records: [GeneralizedSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedSampleTranslationTaxa {\n        records: [TranslationSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedRarefiedSampleTaxa {\n        records: [RarefiedSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedPlankton {\n        records: [PlanktonSample]\n        nextOffset: Int\n    }\n\n    type PaginatedDrift {\n        records: [DriftSample]\n        nextOffset: Int\n    }\n\n    type PaginatedFish {\n        records: [FishSample]\n        nextOffset: Int\n    }\n\n    type PaginatedMass {\n        records: [MassSample]\n        nextOffset: Int\n    }\n\n    type PaginatedAttributes {\n        records: [Attribute]\n        nextOffset: Int\n    }\n\n    type PaginatedAttributeValues {\n        records: [AttributeValue]\n        nextOffset: Int\n    }\n\n    type PaginatedModelConditions {\n        records: [ModelCondition]\n        nextOffset: Int\n    }\n\n    type PaginatedMetrics {\n        records: [Metric]\n        nextOffset: Int\n    }\n\n    type PaginatedMetricResult {\n        records: [MetricResult]\n        nextOffset: Int\n    }\n\n    type PaginatedModelResult {\n        records: [ModelResult]\n        nextOffset: Int\n    }\n\n    type PaginatedFishDiet {\n        records: [FishDiet]\n        nextOffset: Int\n    }\n"])), exports.queryLimits.samples, exports.queryLimits.sites, exports.queryLimits.boxes, exports.queryLimits.projects, exports.queryLimits.predictors, exports.queryLimits.models, exports.queryLimits.sitePredictorValues, exports.queryLimits.modelPredictors, exports.queryLimits.modelResults, exports.queryLimits.taxonomy, exports.queryLimits.taxonomy, exports.queryLimits.taxonomy, exports.queryLimits.taxonomy, exports.queryLimits.translations, exports.queryLimits.samples, exports.queryLimits.samples, exports.queryLimits.samples, exports.queryLimits.samples, exports.queryLimits.samples, exports.queryLimits.metrics);
>>>>>>> 0cbff9e (boxes API endpoint fixes)
exports.default = typeDefs;
var templateObject_1;
//# sourceMappingURL=schema.graphql.js.map