create extension if not exists postgis;
create extension if not exists tablefunc;
create extension if not exists "uuid-ossp";

CREATE FUNCTION fn_before_update()
    RETURNS trigger AS
$$
BEGIN
    NEW.updated_date = now();
    RETURN NEW;
END ;
$$
    LANGUAGE 'plpgsql';

/******************************************************************************************************************
 GEO SCHEMA
 */

CREATE SCHEMA geo;
GRANT USAGE ON SCHEMA geo TO PUBLIC;

CREATE TABLE geo.countries
(
    country_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    country_name VARCHAR(50) UNIQUE NOT NULL,
    abbreviation VARCHAR(5)         NOT NULL,
    geom         GEOMETRY(MultiPolygon, 4326),
    created_date TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ        NOT NULL DEFAULT now()
);
CREATE INDEX gx_countries_geom ON geo.countries USING GIST (geom);
CREATE TRIGGER tr_countries_update
    BEFORE UPDATE
    ON geo.countries
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

CREATE TABLE geo.states
(
    state_id     SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    country_id   SMALLINT    NOT NULL,
    state_name   VARCHAR(50) NOT NULL,
    abbreviation VARCHAR(2)  NOT NULL,
    geom         GEOMETRY(MultiPolygon, 4326),
    created_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_states_country_id FOREIGN KEY (country_id) REFERENCES geo.countries (country_id)
);
CREATE INDEX ix_states_country_id ON geo.states (country_id);
CREATE UNIQUE INDEX ux_states_name ON geo.states (country_id, state_name);
CREATE UNIQUE INDEX ux_states_abbreviation ON geo.states (country_id, abbreviation);
CREATE INDEX gx_states_geom ON geo.states USING GIST (geom);
CREATE TRIGGER tr_states_update
    BEFORE UPDATE
    ON geo.states
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.counties
(
    county_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    state_id     SMALLINT     NOT NULL,
    county_name  VARCHAR(255) NOT NULL,
    geom         GEOMETRY(MultiPolygon, 4326),
    created_date TIMESTAMPTZ  NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ  NOT NULL DEFAULT now(),

    CONSTRAINT fk_counties_state_id FOREIGN KEY (state_id) REFERENCES geo.states (state_id)
);
CREATE INDEX ix_counties_state_id ON geo.counties (state_id);
CREATE UNIQUE INDEX ux_counties_name ON geo.counties (state_id, county_name);
CREATE INDEX gx_counties_geom ON geo.counties USING GIST (geom);
CREATE TRIGGER tr_counties_update
    BEFORE UPDATE
    ON geo.counties
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.land_uses
(
    land_use_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    land_use_name VARCHAR(50) UNIQUE NOT NULL,
    is_active     BOOLEAN            NOT NULL DEFAULT TRUE,
    created_date  TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date  TIMESTAMPTZ        NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_land_uses_update
    BEFORE UPDATE
    ON geo.land_uses
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.ecosystems
(
    ecosystem_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ecosystem_name VARCHAR(10) UNIQUE NOT NULL,
    is_active      BOOLEAN            NOT NULL DEFAULT TRUE,
    description    TEXT,
    created_date   TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date   TIMESTAMPTZ        NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_ecosystems_update
    BEFORE UPDATE
    ON geo.ecosystems
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.habitats
(
    habitat_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    habitat_name VARCHAR(50) UNIQUE NOT NULL,
    ecosystem_id SMALLINT           NOT NULL,
    is_active    BOOLEAN            NOT NULL DEFAULT TRUE,
    created_date TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ        NOT NULL DEFAULT now(),

    CONSTRAINT fk_habitats_ecosystem_id FOREIGN KEY (ecosystem_id) REFERENCES geo.ecosystems (ecosystem_id)
);
CREATE INDEX ix_habitats_ecosystem_id ON geo.habitats (ecosystem_id);
CREATE TRIGGER tr_habitats_update
    BEFORE UPDATE
    ON geo.habitats
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.units
(
    unit_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    unit_name    VARCHAR(50) UNIQUE NOT NULL,
    abbreviation VARCHAR(20) UNIQUE NOT NULL,
    description  TEXT,
    created_date TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ        NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_units_update
    BEFORE UPDATE
    ON geo.units
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.systems
(
    system_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    system_name  VARCHAR(20) UNIQUE NOT NULL,
    ecosystem_id SMALLINT           NOT NULL,
    is_active    BOOLEAN            NOT NULL DEFAULT TRUE,
    created_date TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ        NOT NULL DEFAULT now(),

    CONSTRAINT fk_systems_ecosystem_id FOREIGN KEY (ecosystem_id) REFERENCES geo.ecosystems (ecosystem_id)
);
CREATE INDEX ix_systems_ecosystem_id ON geo.systems (ecosystem_id);
CREATE TRIGGER tr_systems_update
    BEFORE UPDATE
    ON geo.systems
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

CREATE TABLE geo.waterbody_types
(
    waterbody_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    waterbody_type_name VARCHAR(255) UNIQUE NOT NULL,
    metadata            JSON
);

-- TODO: table design incomplete
CREATE TABLE geo.sites
(
    site_id           INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    site_name         VARCHAR(50) UNIQUE    NOT NULL,
    system_id         SMALLINT,
    description       TEXT,
    location          GEOMETRY(Point, 4326) NOT NULL,
    catchment         GEOMETRY(MultiPolygon, 4326),
    waterbody_type_id SMALLINT,
    waterbody_code    VARCHAR(100),
    waterbody_name    VARCHAR(255),
    metadata          JSON,
    geometry_changed  TIMESTAMPTZ           NOT NULL DEFAULT now(),
    created_date      TIMESTAMPTZ           NOT NULL DEFAULT now(),
    updated_date      TIMESTAMPTZ           NOT NULL DEFAULT now(),

    CONSTRAINT fk_sites_system_id FOREIGN KEY (system_id) REFERENCES geo.systems (system_id),
    CONSTRAINT fk_sites_waterbody_type_id FOREIGN KEY (waterbody_type_id) REFERENCES geo.waterbody_types (waterbody_type_id)
);
CREATE INDEX gx_sites_location ON geo.sites USING GIST (location);
CREATE INDEX gx_sites_catchment ON geo.sites USING GIST (catchment);
CREATE INDEX fx_sites_system_id ON geo.sites (system_id);
CREATE INDEX fx_sites_waterbody_type_id ON geo.sites (waterbody_type_id);
CREATE TRIGGER tr_sites_update
    BEFORE UPDATE
    ON geo.sites
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

/*
 Function to update the timestamp that tracks the last time that a site's
 location or catchment were changed. This can be used to determine when
 model predictors need to be recalculated for samples associated with
 this site.
 */
CREATE OR REPLACE FUNCTION fn_before_update_geometry()
    RETURNS trigger AS
$$
BEGIN
    NEW.geometry_changed = now();
    RETURN NEW;
END ;
$$
    LANGUAGE 'plpgsql';

/*
 Trigger to update the timestamp when a site's catchment or location changes.
 This is used to determine when model predictors need to be recalculated for
 samples related to this site.
 */
CREATE TRIGGER tr_sites_geometry_update
    BEFORE UPDATE
        OF catchment, location
    ON geo.sites
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update_geometry();



CREATE TABLE geo.site_catchment_history
(
    catchment_id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    site_id      INT                          NOT NULL,
    catchment    GEOMETRY(MultiPolygon, 4326) NOT NULL,
    description  TEXT,
    created_date TIMESTAMPTZ                  NOT NULL DEFAULT now(),

    CONSTRAINT fk_site_catchment_history_site_id FOREIGN KEY (site_id) REFERENCES geo.sites (site_id) ON DELETE CASCADE
);
CREATE INDEX fx_site_catchment_history_site_id ON geo.site_catchment_history (site_id);
CREATE INDEX gx_site_catchment_history_site_id ON geo.site_catchment_history USING GIST (catchment);

CREATE TABLE geo.site_location_history
(
    location_id  INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    site_id      INT                   NOT NULL,
    location     GEOMETRY(Point, 4326) NOT NULL,
    description  TEXT,
    created_date TIMESTAMPTZ           NOT NULL DEFAULT now(),

    CONSTRAINT fk_site_location_history_site_id FOREIGN KEY (site_id) REFERENCES geo.sites (site_id) ON DELETE CASCADE
);
CREATE INDEX fx_site_location_history_site_id ON geo.site_location_history (site_id);
CREATE INDEX gx_site_location_history_site_id ON geo.site_location_history USING GIST (location);

CREATE TABLE geo.predictor_types
(
    predictor_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    predictor_type_name VARCHAR(255) UNIQUE NOT NULL,
    created_date        TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ         NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_predictor_types_update
    BEFORE UPDATE
    ON geo.predictor_types
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.predictors
(
    predictor_id       SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    predictor_name     VARCHAR(255) UNIQUE NOT NULL,
    abbreviation       VARCHAR(25) UNIQUE  NOT NULL,
    unit_id            SMALLINT            NOT NULL,
    predictor_type_id  SMALLINT            NOT NULL,
    is_temporal        BOOLEAN             NOT NULL,
    description        TEXT,
    metadata           JSON,
    calculation_script VARCHAR(255),
    created_date       TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date       TIMESTAMPTZ         NOT NULL DEFAULT now(),

    CONSTRAINT fk_predictors_unit_id FOREIGN KEY (unit_id) REFERENCES geo.units (unit_id),
    CONSTRAINT fk_predictors_predictor_type_id FOREIGN KEY (predictor_type_id) REFERENCES geo.predictor_types (predictor_type_id)
);
CREATE INDEX fx_predictors_unit_id ON geo.predictors (unit_id);
CREATE INDEX fk_predictors_predictor_type_id ON geo.predictors (predictor_type_id);
CREATE TRIGGER tr_predictors_update
    BEFORE UPDATE
    ON geo.predictors
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

CREATE TABLE geo.model_types
(
    model_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    abbreviation    VARCHAR(20) UNIQUE  NOT NULL,
    model_type_name VARCHAR(255) UNIQUE NOT NULL
);


/******************************************************************************************************************
 ENTITY SCHEMA
 */

CREATE SCHEMA entity;
GRANT USAGE ON SCHEMA entity TO PUBLIC;

CREATE TABLE entity.entities
(
    entity_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parent_id    SMALLINT,
    address1     VARCHAR(255),
    address2     VARCHAR(255),
    city         VARCHAR(255),
    state_id     SMALLINT,
    country_id   SMALLINT    NOT NULL,
    zip_code     VARCHAR(20),
    phone        VARCHAR(50),
    fax          VARCHAR(50),
    website      VARCHAR(255),
    notes        TEXT,
    metadata     JSON,
    created_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_entities_parent_id FOREIGN KEY (parent_id) REFERENCES entity.entities (entity_id),
    CONSTRAINT fk_entities_state_id FOREIGN KEY (state_id) REFERENCES geo.states (state_id),
    CONSTRAINT fk_entities_country_id FOREIGN KEY (country_id) REFERENCES geo.countries (country_id)
);
CREATE INDEX fx_entities_state_id ON entity.entities (state_id);
CREATE INDEX fx_entities_country_id ON entity.entities (country_id);
CREATE TRIGGER tr_entities_update
    BEFORE UPDATE
    ON entity.entities
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

CREATE TABLE entity.organization_types
(
    organization_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    organization_type_name VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE entity.organizations
(
    entity_id            SMALLINT NOT NULL PRIMARY KEY,
    abbreviation         VARCHAR(50),
    organization_name    VARCHAR(255),
    organization_type_id SMALLINT NOT NULL,
    is_lab               BOOLEAN  NOT NULL DEFAULT FALSE,

    CONSTRAINT fk_organizations_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities (entity_id) ON DELETE CASCADE,
    CONSTRAINT fk_organizations_organization_type_id FOREIGN KEY (organization_type_id) REFERENCES entity.organization_types (organization_type_id)
);
CREATE UNIQUE INDEX ux_organizations_entity_id ON entity.organizations (entity_id);
CREATE INDEX fx_organizations_organization_type_id ON entity.organizations (organization_type_id);

CREATE TABLE entity.individuals
(
    entity_id      SMALLINT    NOT NULL PRIMARY KEY,
    first_name     VARCHAR(50) NOT NULL,
    last_name      VARCHAR(50) NOT NULL,
    initials       VARCHAR(3),
    affiliation_id SMALLINT,
    email          VARCHAR(255),
    title          VARCHAR(255),
    cognito_sub    VARCHAR(255),

    CONSTRAINT fk_individuals_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities (entity_id) ON DELETE CASCADE,
    CONSTRAINT fk_individuals_affiliation_id FOREIGN KEY (affiliation_id) REFERENCES entity.organizations (entity_id)
);
CREATE UNIQUE INDEX ux_individuals_entity_id ON entity.individuals (entity_id);
CREATE INDEX fx_individuals_affiliation_id ON entity.individuals (affiliation_id);


CREATE TABLE entity.roles
(
    role_id     SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    role_name   VARCHAR(255) UNIQUE NOT NULL,
    description TEXT
);

CREATE TABLE entity.individual_roles
(
    entity_id SMALLINT NOT NULL,
    role_id   SMALLINT NOT NULL,

    CONSTRAINT pk_individuals_roles PRIMARY KEY (entity_id, role_id),
    CONSTRAINT fk_individual_roles_entity_id FOREIGN KEY (entity_id) REFERENCES entity.individuals (entity_id) ON DELETE CASCADE,
    CONSTRAINT fk_individual_roles_role_id FOREIGN KEY (role_id) REFERENCES entity.roles (role_id)
);


CREATE TABLE entity.communications
(
    history_id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    entity_id    SMALLINT,
    employee_id  SMALLINT    NOT NULL,
    notes        TEXT,
    metadata     JSON,
    created_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_history_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities (entity_id),
    CONSTRAINT fk_history_namc_staff_id FOREIGN KEY (employee_id) REFERENCES entity.individuals (entity_id)
);
CREATE INDEX fx_entities_history_entity_id ON entity.communications (entity_id);
CREATE INDEX fx_entities_history_employee_id ON entity.communications (employee_id);


CREATE TABLE entity.lab_types
(
    lab_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    lab_type_name VARCHAR(255) UNIQUE NOT NULL
);


/******************************************************************************************************************
 Taxa SCHEMA
 */

CREATE SCHEMA taxa;
GRANT USAGE ON SCHEMA taxa TO PUBLIC;

CREATE TABLE taxa.taxa_levels
(
    level_id        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    level_name      VARCHAR(50) UNIQUE NOT NULL,
    parent_level_id SMALLINT UNIQUE,
    rank_order      smallint not null,
    is_active       BOOLEAN            NOT NULL DEFAULT TRUE,
    description     TEXT,

    CONSTRAINT fk_taxa_levels_parent_level_id FOREIGN KEY (parent_level_id) REFERENCES taxa.taxa_levels (level_id)
);

CREATE TABLE taxa.life_stages
(
    life_stage_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    abbreviation    CHAR(1) UNIQUE     NOT NULL,
    life_stage_name VARCHAR(50) UNIQUE NOT NULL,
    is_active       BOOLEAN            NOT NULL DEFAULT TRUE
);

CREATE TABLE taxa.taxonomy
(
    taxonomy_id     SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    scientific_name VARCHAR(255) NOT NULL,
    level_id        SMALLINT     NOT NULL,
    parent_id       SMALLINT,
    author          VARCHAR(255),
    year            SMALLINT,
    created_date    TIMESTAMPTZ  NOT NULL DEFAULT now(),
    updated_date    TIMESTAMPTZ  NOT NULL DEFAULT now(),

    CONSTRAINT fk_organism_taxonomy_taxa_level_id FOREIGN KEY (level_id) REFERENCES taxa.taxa_levels (level_id)
);
CREATE INDEX fx_organism_taxonomy_taxa_level_id ON taxa.taxonomy (level_id);
CREATE TRIGGER tr_taxonomy_update
    BEFORE UPDATE
    ON taxa.taxonomy
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE taxa.synonyms
(
    synonym_id  SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    taxonomy_id SMALLINT     NOT NULL,
    synonym     VARCHAR(255) NOT NULL,

    CONSTRAINT fk_synonyms_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy (taxonomy_id) ON DELETE CASCADE
);
CREATE INDEX fx_synonyms_taxonomy_id ON taxa.synonyms (taxonomy_id);

CREATE TYPE ATTRIBUTE_TYPES AS ENUM ('Float', 'Integer', 'Text', 'Unknown');


CREATE TABLE taxa.attributes
(
    attribute_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    attribute_name VARCHAR(255) UNIQUE NOT NULL,
    attribute_type ATTRIBUTE_TYPES     NOT NULL,
    label          VARCHAR(255),
    description    TEXT,
    metadata       JSON,

    created_date   TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date   TIMESTAMPTZ         NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_attributes_update
    BEFORE UPDATE
    ON taxa.attributes
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE taxa.taxa_attributes
(
    taxonomy_id     SMALLINT     NOT NULL,
    attribute_id    SMALLINT     NOT NULL,
    attribute_value VARCHAR(100) NOT NULL,

    CONSTRAINT pk_taxa_attributes PRIMARY KEY (taxonomy_id, attribute_id),
    CONSTRAINT fk_taxa_attributes_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy (taxonomy_id) ON DELETE CASCADE,
    CONSTRAINT fk_taxa_attributes_attribute_id FOREIGN KEY (attribute_id) REFERENCES taxa.attributes (attribute_id)
);

/*
 ITIS
 Encyc of Life
 Wiki Species
 */
CREATE TABLE taxa.external_sources
(
    source_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    source_name  VARCHAR(255) UNIQUE NOT NULL,
    abbreviation VARCHAR(10) UNIQUE  NOT NULL,
    description  TEXT,
    metadata     JSONB
);


CREATE TABLE taxa.external_ids
(
    source_id          SMALLINT NOT NULL,
    taxonomy_id        SMALLINT NOT NULL,
    external_source_id VARCHAR(255),
    scientific_name    VARCHAR(255),

    CONSTRAINT pk_external_ids PRIMARY KEY (source_id, taxonomy_id),
    CONSTRAINT fk_external_ids_source_id FOREIGN KEY (source_id) REFERENCES taxa.external_sources (source_id) ON DELETE CASCADE,
    CONSTRAINT fk_external_ids_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy (taxonomy_id)
);


CREATE TABLE taxa.translations
(
    translation_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    translation_name VARCHAR(255) UNIQUE NOT NULL,
    description      TEXT,
    is_active        BOOLEAN             NOT NULL DEFAULT TRUE,

    created_date     TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date     TIMESTAMPTZ         NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_translations_update
    BEFORE UPDATE
    ON taxa.translations
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE taxa.taxa_translations
(
    translation_taxonomy_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    translation_id            SMALLINT NOT NULL,
    taxonomy_id               SMALLINT NOT NULL,
    translation_taxonomy_name VARCHAR(255),

    CONSTRAINT fk_taxa_translations_translation_id FOREIGN KEY (translation_id) REFERENCES taxa.translations (translation_id) ON DELETE CASCADE,
    CONSTRAINT fk_taxa_translations_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy (taxonomy_id)
);
CREATE INDEX fx_taxa_translations_taxonomy_id ON taxa.taxa_translations (taxonomy_id);
CREATE UNIQUE INDEX ux_taxa_translations_taxonomy_id ON taxa.taxa_translations (translation_id, taxonomy_id);

CREATE TABLE taxa.translation_predictors
(
    translation_id SMALLINT NOT NULL,
    predictor_id   SMALLINT NOT NULL,

    CONSTRAINT pk_taxa_translation_predictors PRIMARY KEY (translation_id, predictor_id),
    CONSTRAINT fk_taxa_translation_predictors_translation_id FOREIGN KEY (translation_id) REFERENCES taxa.translations (translation_id) ON DELETE CASCADE,
    CONSTRAINT fk_taxa_translation_predictors_predictor_id FOREIGN KEY (predictor_id) REFERENCES geo.predictors (predictor_id)
);

CREATE TABLE taxa.references
(
    reference_id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    authors      VARCHAR(255) NOT NULL,
    year         SMALLINT     NOT NULL,
    title        TEXT,
    publication  TEXT,
    url          TEXT,
    created_date TIMESTAMPTZ  NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ  NOT NULL DEFAULT now()
);

CREATE TYPE TAXONOMIC_EFFORT AS ENUM ('Standard', 'Midges');


-- TODO: Make extent required field
CREATE TABLE geo.models
(
    model_id           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    model_name         VARCHAR(255) UNIQUE NOT NULL,
    abbreviation       VARCHAR(50) UNIQUE  NOT NULL,
    model_type_id      SMALLINT            NOT NULL,
    translation_id     SMALLINT,
    extent             GEOMETRY(MultiPolygon, 4326),
    extent_description TEXT,
    platform           VARCHAR(255),
    reference_sites    SMALLINT,
    group_count        SMALLINT,
    minimum_count      SMALLINT,
    oe_mean            REAL,
    oe_stdev           REAL,
    taxonomic_effort   TAXONOMIC_EFFORT,
    is_active          BOOLEAN             NOT NULL DEFAULT TRUE,
    fixed_count        SMALLINT,
    unit_id            SMALLINT            NOT NULL,
    description        TEXT,
    metadata           JSON,
    created_date       TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date       TIMESTAMPTZ         NOT NULL DEFAULT now(),

    CONSTRAINT fk_models_units_id FOREIGN KEY (unit_id) REFERENCES geo.units (unit_id),
    CONSTRAINT fk_models_model_type_id FOREIGN KEY (model_type_id) REFERENCES geo.model_types (model_type_id),
    CONSTRAINT fk_models_translation_id FOREIGN KEY (translation_id) REFERENCES taxa.translations (translation_id),
    CONSTRAINT ck_models_fixed_count CHECK (fixed_count > 0),
    CONSTRAINT ck_models_reference_sites CHECK (reference_sites > 0),
    CONSTRAINT ck_models_group_count CHECK (group_count > 0),
    CONSTRAINT ck_models_minimum_count CHECK (minimum_count > 0)

);
CREATE INDEX gx_models_extent ON geo.models USING GIST (extent);
CREATE INDEX fx_models_unit_id ON geo.models (unit_id);
CREATE INDEX fx_models_model_type_id ON geo.models (model_type_id);
CREATE INDEX fx_models_translation_id ON geo.models (translation_id);

CREATE TABLE geo.model_thresholds
(
    threshold_id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    model_id     SMALLINT    NOT NULL,
    display_text VARCHAR(50) NOT NULL,
    description  TEXT,
    threshold    numrange    NOT NULL,

    CONSTRAINT fk_model_thresholds_model_id FOREIGN KEY (model_id) REFERENCES geo.models (model_id) ON DELETE CASCADE
);
CREATE UNIQUE INDEX ux_model_thresholds_model_id ON geo.model_thresholds (model_id, display_text);
CREATE UNIQUE INDEX ux_model_thresholds_model_threshold ON geo.model_thresholds (model_id, threshold);
CREATE INDEX ix_model_thresholds_threshold ON geo.model_thresholds USING gist (threshold);

CREATE TABLE geo.model_predictors
(
    model_id     SMALLINT NOT NULL,
    predictor_id SMALLINT NOT NULL,

    CONSTRAINT pk_model_predictors PRIMARY KEY (model_id, predictor_id),
    CONSTRAINT fk_model_predictors_model_id FOREIGN KEY (model_id) REFERENCES geo.models (model_id) ON DELETE CASCADE,
    CONSTRAINT fk_model_predictors_predictor_id FOREIGN KEY (predictor_id) REFERENCES geo.predictors (predictor_id)
);

CREATE TABLE geo.site_predictors
(
    predictor_id    SMALLINT     NOT NULL,
    site_id         INT          NOT NULL,
    predictor_value VARCHAR(255) NOT NULL,
    created_date    TIMESTAMPTZ  NOT NULL DEFAULT now(),
    updated_date    TIMESTAMPTZ  NOT NULL DEFAULT now(),

    CONSTRAINT pk_site_predictors PRIMARY KEY (predictor_id, site_id, created_date),
    CONSTRAINT fk_site_predictors FOREIGN KEY (predictor_id) REFERENCES geo.predictors (predictor_id),
    CONSTRAINT fk_site_site_id FOREIGN KEY (site_id) REFERENCES geo.sites (site_id)
);
CREATE INDEX fx_site_predictors_site_id ON geo.site_predictors (site_id);
CREATE TRIGGER tr_site_predictors_update
    BEFORE UPDATE
    ON geo.site_predictors
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE entity.entity_models
(
    entity_id SMALLINT NOT NULL,
    model_id  SMALLINT NOT NULL,

    CONSTRAINT pk_entity_models PRIMARY KEY (entity_id, model_id),
    CONSTRAINT fk_entity_models_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities (entity_id) ON DELETE CASCADE,
    CONSTRAINT fk_entity_models_model_id FOREIGN KEY (model_id) REFERENCES geo.models (model_id) ON DELETE CASCADE
);
CREATE INDEX fx_entity_models_model_id ON entity.entity_models (model_id);
COMMENT ON TABLE entity.entity_models IS 'Associates models with customer entities. The models associated with an entity'
    'are considered the default models for each customer. Deleting either a model or customer entity deletes all '
    'associated records in this table.';


/******************************************************************************************************************
 SAMPLE SCHEMA
 */

CREATE SCHEMA sample;
GRANT USAGE ON SCHEMA sample TO PUBLIC;

CREATE TABLE sample.sample_methods
(
    sample_method_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_method_name VARCHAR(50) UNIQUE NOT NULL,
    is_active          BOOLEAN            NOT NULL DEFAULT TRUE,
    created_date       TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date       TIMESTAMPTZ        NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_sample_methods_update
    BEFORE UPDATE
    ON sample.sample_methods
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.sample_types
(
    sample_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_type_name VARCHAR(50) UNIQUE NOT NULL,
    is_active        BOOLEAN            NOT NULL DEFAULT TRUE,
    created_date     TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date     TIMESTAMPTZ        NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_sample_types
    BEFORE UPDATE
    ON sample.sample_types
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.box_states
(
    box_state_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    box_state_name  VARCHAR(50) UNIQUE NOT NULL,
    box_state_order SMALLINT UNIQUE    NOT NULL,
    description     TEXT,
    is_active       BOOLEAN            NOT NULL DEFAULT TRUE,

    CONSTRAINT chk_box_states CHECK (box_state_order > 0)
);

CREATE TABLE sample.project_types
(
    project_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    project_type_name VARCHAR(255) UNIQUE NOT NULL,
    description       TEXT,
    is_active         BOOLEAN             NOT NULL DEFAULT TRUE
);

/*
 deactivated date is flag that gets set when a project is deleted.
 Deleted projects remain in database until they are purged by hand
 or automated scrape at predetermined interval.
 */
CREATE TABLE sample.projects
(
    project_id          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    project_name        VARCHAR(255) UNIQUE NOT NULL,
    project_type_id     SMALLINT            NOT NULL,
    is_private          BOOLEAN                      DEFAULT TRUE,
    contact_id          SMALLINT,
    extent              GEOMETRY(MultiPolygon, 4326),
    auto_update_samples BOOLEAN             NOT NULL DEFAULT FALSE,
    description         TEXT,
    metadata            JSON,
    deleted_date        TIMESTAMPTZ,
    created_date        TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ         NOT NULL DEFAULT now(),

    CONSTRAINT fk_projects_contact_id FOREIGN KEY (contact_id) REFERENCES entity.entities (entity_id),
    CONSTRAINT fk_projects_project_type_id FOREIGN KEY (project_type_id) REFERENCES sample.project_types (project_type_id)
);
CREATE INDEX fx_projects_contact_id ON sample.projects (contact_id);
CREATE INDEX fx_projects_project_type_id ON sample.projects (project_type_id);
CREATE INDEX gx_projects_extent ON sample.projects USING GIST (extent);
CREATE TRIGGER tr_projects_update
    BEFORE UPDATE
    ON sample.projects
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

CREATE TABLE sample.project_models
(
    project_id SMALLINT NOT NULL,
    model_id   SMALLINT NOT NULL,

    CONSTRAINT pk_sample_project_models PRIMARY KEY (project_id, model_id),
    CONSTRAINT fk_sample_project_models_project_id FOREIGN KEY (project_id) REFERENCES sample.projects (project_id) ON DELETE CASCADE,
    CONSTRAINT fk_sample_project_models_model_id FOREIGN KEY (model_id) REFERENCES geo.models (model_id) ON DELETE CASCADE
);
CREATE INDEX fx_project_models_model_id ON sample.project_models (model_id);
COMMENT ON TABLE sample.project_models IS 'Associates projects with models.';


-- TODO: table design incomplete
-- TODO: review columns copied from PilotDB.BugTacking
-- TODO: UsuTrack changed from FLOAT to SMALLINT
-- TODO: hook up billing_cust_id to customers? Confirm purpose
-- TODO: Default icost and tcost to zero?
-- TODO: add sort_time and id_time as summary columns on view
CREATE TABLE sample.boxes
(
    box_id                   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_id              SMALLINT    NOT NULL,
    submitter_id             SMALLINT    NOT NULL,
    box_state_id             SMALLINT    NOT NULL,
    box_received_date        TIMESTAMPTZ,                        -- date the box arrives
    processing_complete_date TIMESTAMPTZ,                        -- date lab processing is complete
    projected_complete_date  TIMESTAMPTZ,                        -- report_ready, available to customer, customer notified. all data QAed.
    description              TEXT,
    metadata                 JSON,
    measurements             BOOLEAN     NOT NULL DEFAULT FALSE, -- things customers can be billed for (fee per sample) checkbox in submission UI
    sorter_qa                BOOLEAN     NOT NULL DEFAULT FALSE, -- things customers can be billed for (fee per sample) checkbox in submission UI
    taxa_qa                  BOOLEAN     NOT NULL DEFAULT FALSE, -- things customers can be billed for (fee per sample) checkbox in submission UI
    created_date             TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date             TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_boxes_customer_id FOREIGN KEY (customer_id) REFERENCES entity.entities (entity_id),
    CONSTRAINT fk_boxes_submitter_id FOREIGN KEY (submitter_id) REFERENCES entity.individuals (entity_id),
    CONSTRAINT fk_boxes_state_id FOREIGN KEY (box_state_id) REFERENCES sample.box_states (box_state_id)
);
CREATE INDEX fx_boxes_customer_id ON sample.boxes (customer_id);
CREATE INDEX fx_boxes_status_id ON sample.boxes (box_state_id);
CREATE TRIGGER tr_boxes_update
    BEFORE UPDATE
    ON sample.boxes
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.box_models
(
    box_id   INT NOT NULL,
    model_id INT NOT NULL,

    CONSTRAINT pk_box_models PRIMARY KEY (box_id, model_id),
    CONSTRAINT fk_box_models_box_id FOREIGN KEY (box_id) REFERENCES sample.boxes (box_id) ON DELETE CASCADE,
    CONSTRAINT fk_box_models_model_id FOREIGN KEY (model_id) REFERENCES geo.models (model_id) ON DELETE CASCADE
);
CREATE INDEX fx_box_models ON sample.box_models (model_id);
COMMENT ON TABLE sample.box_models IS 'Associates boxes with models. This determines which models are '
    'required for each box once sample processing is complete.';


-- TODO: Should this table have it's own primary key so that it can
-- store each version of the submission should it be edited by NAMC
-- after it is submitted. It must be possible to always find the latest
-- version either using the created_date or the largest primary key.
-- sample records do not get created until pending QA process is
-- completed.

CREATE TABLE sample.submissions
(
    submission_id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    box_id          INT         NOT NULL,
    version_id      INT         NOT NULL,
    metadata        JSONB       NOT NULL,
    submitted_by_id SMALLINT    NOT NULL,
    created_date    TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date    TIMESTAMPTZ NOT NULL DEFAULT now(),


    CONSTRAINT fk_submissions_box_id FOREIGN KEY (box_id) REFERENCES sample.boxes (box_id) ON DELETE CASCADE,
    CONSTRAINT fk_submissions_submitted_by_id FOREIGN KEY (submitted_by_id) REFERENCES entity.individuals (entity_id)

);
CREATE UNIQUE INDEX ux_submissions_box_id ON sample.submissions (box_id, version_id);
CREATE INDEX fx_submissions_submitted_by_id ON sample.submissions (submitted_by_id);
CREATE TRIGGER tr_sumbissions_update
    BEFORE UPDATE
    ON sample.submissions
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


-- TODO: Verify that it's OK to make qualitative NOT NULL and check what the default should be
-- TODO: verify that Count field is not needed?
-- TODO: verify that SorterChironomidae is needed?
-- TODO: what is the field PilotDB.BugSample.MainID?
-- TODO: what is the field PilotDB.BugSample.Replicates?
-- TODO: what is the field PilotDB.BugSample.Archive?
-- TODO: I have converted mesh FROM FLOAT to SMALLINT. OK? Values are 56, 120, 180, 425
-- Jar count is the initial number of jars that the customer sends for each sample
CREATE TABLE sample.samples
(
    sample_id           INT GENERATED BY DEFAULT AS IDENTITY,
    box_id              INT         NOT NULL,
    site_id             INT,
    visit_id            VARCHAR(100),
    location            GEOMETRY(Point, 4326),          -- NOT NULL,
    sample_date         DATE,
    sample_time         TIME,
    type_id             SMALLINT    NOT NULL,
    method_id           SMALLINT    NOT NULL,
    habitat_id          SMALLINT    NOT NULL,
    area                REAL,
    field_split         REAL,                           -- big sample... in the field keep only 0.5 (50%) or 0.25 (25%) (not submitting the bit they don't keep)
    field_notes         TEXT,
    lab_split           REAL,                           -- lab puts all sample in bucket and sorts 0.25 (25%) or 0.5 (50%)
    jar_count           SMALLINT    NOT NULL DEFAULT 1, -- lab person verifies the jars match the number in the submission form.
    qualitative         BOOLEAN              DEFAULT FALSE,
    lab_notes           TEXT,
    mesh                SMALLINT,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    sample_date_changed TIMESTAMPTZ NOT NULL DEFAULT now(),
    qa_sample_id        INT,
    metadata            JSON,

    CONSTRAINT pk_samples PRIMARY KEY (sample_id),
    CONSTRAINT fk_samples_box_id FOREIGN KEY (box_id) REFERENCES sample.boxes (box_id) ON DELETE CASCADE,
    CONSTRAINT fk_samples_site_id FOREIGN KEY (site_id) REFERENCES geo.sites (site_id),
    CONSTRAINT fk_samples_type_id FOREIGN KEY (type_id) REFERENCES sample.sample_types (sample_type_id),
    CONSTRAINT fk_samples_method_id FOREIGN KEY (method_id) REFERENCES sample.sample_methods (sample_method_id),
    CONSTRAINT fk_samples_habitat_id FOREIGN KEY (habitat_id) REFERENCES geo.habitats (habitat_id),
    CONSTRAINT ck_samples_area CHECK (area >= 0),
    CONSTRAINT ck_samples_field_split CHECK (field_split >= 0 AND field_split <= 1.0),
    CONSTRAINT ck_samples_lab_split CHECK (lab_split >= 0 AND lab_split <= 1.0),
    CONSTRAINT chk_samples_mesh CHECK (mesh > 0),
    CONSTRAINT chk_samples_jar_count CHECK (jar_count > 0)
);
CREATE INDEX fx_samples_box_id ON sample.samples (box_id);
CREATE INDEX fx_samples_site_id ON sample.samples (site_id);
CREATE INDEX fx_samples_visit_id ON sample.samples (visit_id);
CREATE INDEX gx_samples_location ON sample.samples USING GIST (location);
CREATE INDEX fx_samples_type_id ON sample.samples (type_id);
CREATE INDEX fx_samples_method_id ON sample.samples (method_id);
CREATE INDEX fx_samples_habitat_id ON sample.samples (habitat_id);
CREATE TRIGGER tr_samples_update
    BEFORE UPDATE
    ON sample.samples
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

/*
 Function to track when a sample has its sample date changed.
 This helps determine when temporal model predictors need to be
 updated because the sample may have occurred on a different date.
 */
CREATE OR REPLACE FUNCTION fn_before_sample_date_change()
    RETURNS trigger AS
$$
BEGIN
    NEW.sample_date_changed = now();
    RETURN NEW;
END ;
$$
    LANGUAGE 'plpgsql';

/*
 Trigger to track when a samples date changes.
 */
CREATE TRIGGER tr_sample_sample_date_update
    BEFORE UPDATE
        OF sample_date_changed
    ON sample.samples
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_sample_date_change();

CREATE TABLE sample.sorter_time
(
    sorter_time_id  INT      NOT NULL GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_id       INT      NOT NULL,
    sorter_id       SMALLINT NOT NULL,
    sorter_count    SMALLINT,
    elutriation     BOOLEAN  NOT NULL DEFAULT FALSE,
    sort_time       REAL     NOT NULL DEFAULT 0,
    sort_start_date TIMESTAMPTZ,
    sort_end_date   TIMESTAMPTZ,
    is_qa           BOOLEAN  NOT NULL DEFAULT FALSE,

    CONSTRAINT fk_sorter_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id),
    CONSTRAINT fk_sorter_sorter_id FOREIGN KEY (sorter_id) REFERENCES entity.individuals (entity_id),
    CONSTRAINT ck_sorter_sorter_count CHECK (sorter_count >= 0)
);
CREATE INDEX fx_sorter_time_sample_id ON sample.sorter_time (sample_id);
CREATE INDEX fx_sorter_time_sorter_id ON sample.sorter_time (sorter_id);


CREATE TABLE sample.taxa_time
(
    taxa_time_id  INT  NOT NULL GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_id     INT  NOT NULL,
    id_er         INT  NOT NULL,
    id_time       REAL NOT NULL DEFAULT 0,
    id_start_date timestamptz,
    id_end_date   timestamptz,

    CONSTRAINT fk_taxa_time_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id),
    CONSTRAINT fk_taxa_time_id_ier FOREIGN KEY (id_er) REFERENCES entity.individuals (entity_id)
);
CREATE INDEX fx_taxa_time_sample_id ON sample.taxa_time (sample_id);
CREATE INDEX fx_taxa_time_id_er ON sample.taxa_time (id_er);


CREATE TABLE sample.sample_labs
(
    sample_id   INT      NOT NULL,
    entity_id   SMALLINT NOT NULL,
    lab_type_id SMALLINT NOT NULL,

    CONSTRAINT pk_sample_labs PRIMARY KEY (sample_id, entity_id, lab_type_id),
    CONSTRAINT fk_sample_labs_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_sample_labs_entity_id FOREIGN KEY (entity_id) REFERENCES entity.organizations (entity_id),
    CONSTRAINT fk_sample_labs_lab_type_id FOREIGN KEY (lab_type_id) REFERENCES entity.lab_types (lab_type_id)
);


CREATE TYPE TOW_TYPES AS ENUM ('Vertical', 'Horizontal');

CREATE TABLE sample.plankton
(
    sample_id        INT         NOT NULL PRIMARY KEY,
    diameter         REAL,
    sub_sample_count SMALLINT,
    tow_length       REAL,
    volume           REAL,
    aliquot          REAL,
    size_interval    REAL,
    tow_type         TOW_TYPES,
    updated_date     TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_plankton_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT ck_plankton_diameter CHECK (diameter > 0),
    CONSTRAINT ck_plankton_sub_sample_count CHECK (sub_sample_count >= 0),
    CONSTRAINT ck_plankton_tow_length CHECK (tow_length > 0),
    CONSTRAINT ck_plankton_volume CHECK (volume > 0),
    CONSTRAINT ck_plankton_size_interval CHECK (size_interval > 0)
);
CREATE TRIGGER tr_plankton_update
    BEFORE UPDATE
    ON sample.plankton
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

/*
 used to be net diameter - meaningless for rectangular nets.

 metrics work off of volumes. So need to get the diameters into areas
 */
CREATE TABLE sample.drift
(
    sample_id    INT         NOT NULL PRIMARY KEY,
    net_area     FLOAT,
    net_duration FLOAT,
    stream_depth FLOAT,
    net_depth    FLOAT,
    net_velocity FLOAT,
    updated_date TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT ck_bug_drift_net_area CHECK (net_area > 0),
    CONSTRAINT ck_bug_drift_net_duration CHECK (net_duration > 0),
    CONSTRAINT ck_bug_drift_stream_depth CHECK (stream_depth > 0),
    CONSTRAINT ck_bug_drift_net_depth CHECK (net_depth > 0),
    CONSTRAINT ck_bug_drift_net_velocity CHECK (net_velocity >= 0)
);
CREATE TRIGGER tr_drift_update
    BEFORE UPDATE
    ON sample.drift
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

CREATE TABLE sample.mass_methods
(
    mass_method_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    mass_method_name VARCHAR(255) UNIQUE NOT NULL,
    abbreviation     VARCHAR(15) UNIQUE  NOT NULL,
    is_active        BOOLEAN             NOT NULL DEFAULT TRUE
);

CREATE TABLE sample.mass_types
(
    mass_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    mass_type_name VARCHAR(255) UNIQUE NOT NULL,
    abbreviation   VARCHAR(15) UNIQUE  NOT NULL,
    is_active      BOOLEAN             NOT NULL DEFAULT TRUE
);

/*
 AFDM = Ash free dry mass
 The old bug o matter table used to have AFDM column. IT was a sum of several
 different kinds of mass.
 */
CREATE TABLE sample.mass
(
    sample_id      INT         NOT NULL,
    mass_type_id   SMALLINT    NOT NULL,
    mass_method_id SMALLINT    NOT NULL,
    mass           REAL        NOT NULL,
    updated_date   TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT pk_mass PRIMARY KEY (sample_id, mass_type_id),
    CONSTRAINT fk_mass_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_mass_mass_type_id FOREIGN KEY (mass_type_id) REFERENCES sample.mass_types (mass_type_id),
    CONSTRAINT fk_mass_method_id FOREIGN KEY (mass_method_id) REFERENCES sample.mass_methods (mass_method_id)
);
CREATE INDEX fx_mass_type_id ON sample.mass (mass_type_id);
CREATE INDEX fx_mass_method_id ON sample.mass (mass_method_id);
CREATE TRIGGER tr_mass_update
    BEFORE UPDATE
    ON sample.mass
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

-- BugOMatter table
-- not all records are AFDM. The type
CREATE TABLE sample.taxa_mass
(
    sample_id      INT      NOT NULL,
    taxa_id        SMALLINT NOT NULL,
    mass_type_id   SMALLINT NOT NULL,
    mass_method_id SMALLINT NOT NULL,
    mass           REAL     NOT NULL,
    notes          TEXT
);

-- TODO PilotDB.Stomachs.Code is NULL and the species column has species as text
CREATE TABLE sample.fish
(
    sample_id    INT         NOT NULL PRIMARY KEY,
    taxonomy_id  SMALLINT    NOT NULL,
    fish_length  REAL,
    fish_mass    REAL,
    updated_date TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_fish_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_fish_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy (taxonomy_id),
    CONSTRAINT ck_fish_fish_length CHECK (fish_length >= 0),
    CONSTRAINT ck_fish_fish_mass CHECK (fish_mass >= 0)
);
CREATE INDEX fish_taxa_id ON sample.fish (taxonomy_id);
CREATE TRIGGER tr_fish_update
    BEFORE UPDATE
    ON sample.fish
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

/*
 metadata key "pre_reconciliation_taxonomy_id" is the
 taxonomy_id before the taxonomic reconciliation process.

 We don't want to store multiple records for the same
 organism, distinguished by some "valid/invalid" flag
 for fear that users will forget to filter by this flag.
 */
CREATE TABLE sample.organisms
(
    organism_id    INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_id      INT         NOT NULL,
    taxonomy_id    SMALLINT    NOT NULL,
    life_stage_id  SMALLINT    NOT NULL,
    bug_size       REAL,
    split_count    REAL,
    big_rare_count SMALLINT,
    metadata       JSON,
    notes          TEXT,
    created_date   TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date   TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_organisms_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_organisms_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy (taxonomy_id),
    CONSTRAINT fk_organisms_life_stage_id FOREIGN KEY (life_stage_id) REFERENCES taxa.life_stages (life_stage_id)
);
CREATE UNIQUE INDEX ux_organism_organisms ON sample.organisms (sample_id, taxonomy_id, life_stage_id, bug_size);
CREATE INDEX fx_organisms_taxonomy_id ON sample.organisms (taxonomy_id);
CREATE INDEX fx_organisms_life_stage_id ON sample.organisms (life_stage_id);
CREATE TRIGGER tr_organisms_update
    BEFORE UPDATE
    ON sample.organisms
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();



CREATE TABLE sample.note_types
(
    note_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    note_name    VARCHAR(25) UNIQUE NOT NULL,
    abbreviation CHAR(1) UNIQUE     NOT NULL,
    description  TEXT,
    is_active    BOOLEAN            NOT NULL DEFAULT TRUE,

    created_date TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ        NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_note_types_update
    BEFORE UPDATE
    ON sample.note_types
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.organism_notes
(
    organism_id INT      NOT NULL,
    note_id     SMALLINT NOT NULL,

    CONSTRAINT pk_organism_types PRIMARY KEY (organism_id, note_id),
    CONSTRAINT fk_organism_types_organism_id FOREIGN KEY (organism_id) REFERENCES sample.organisms (organism_id) ON DELETE CASCADE,
    CONSTRAINT fk_organism_types_note_id FOREIGN KEY (note_id) REFERENCES sample.note_types (note_id)
);

-- TODO: would this table be better named as sample.asset_types
CREATE TABLE sample.asset_types
(
    asset_type_id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    asset_name    VARCHAR(255) NOT NULL UNIQUE,
    description   TEXT,
    is_active     BOOLEAN      NOT NULL DEFAULT TRUE,

    created_date  TIMESTAMPTZ  NOT NULL DEFAULT now(),
    updated_date  TIMESTAMPTZ  NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_asset_types_update
    BEFORE UPDATE
    ON sample.asset_types
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

CREATE TABLE sample.assets
(
    asset_id      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    asset_type_id SMALLINT            NOT NULL,
    uuid          VARCHAR(255) UNIQUE NOT NULL,
    created_date  TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date  TIMESTAMPTZ         NOT NULL DEFAULT now(),

    CONSTRAINT fk_sample_assets_asset_type_id FOREIGN KEY (asset_type_id) REFERENCES sample.asset_types (asset_type_id)
);
CREATE INDEX fx_sample_assets_asset_type_id ON sample.assets (asset_type_id);
CREATE INDEX fx_sample_assets_uuid ON sample.assets (uuid);

CREATE TABLE sample.sample_assets
(
    sample_id    INT         NOT NULL,
    asset_id     INT         NOT NULL,
    created_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT pk_sample_assets PRIMARY KEY (sample_id, asset_id),
    CONSTRAINT fk_sample_assets_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_sample_assets_asset_id FOREIGN KEY (asset_id) REFERENCES sample.assets (asset_id)
);


CREATE TABLE sample.box_assets
(
    box_id       INT         NOT NULL,
    asset_id     INT         NOT NULL,
    created_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT pk_sample_box_assets PRIMARY KEY (box_id, asset_id),
    CONSTRAINT fk_sample_box_assets_box_id FOREIGN KEY (box_id) REFERENCES sample.boxes (box_id),
    CONSTRAINT fk_sample_box_assets_asset_id FOREIGN KEY (asset_id) REFERENCES sample.assets (asset_id)
);

CREATE TABLE sample.sample_predictors
(
    sample_id       INT          NOT NULL,
    predictor_id    SMALLINT     NOT NULL,
    predictor_value VARCHAR(255) NOT NULL,
    created_date    TIMESTAMPTZ  NOT NULL DEFAULT now(),
    updated_date    TIMESTAMPTZ  NOT NULL DEFAULT now(),

    CONSTRAINT pk_sample_predictors PRIMARY KEY (sample_id, predictor_id, created_date),
    CONSTRAINT fk_sample_predictors_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_sample_predictors_predictor_id FOREIGN KEY (predictor_id) REFERENCES geo.predictors (predictor_id) ON DELETE CASCADE
);
CREATE INDEX fx_sample_predictors_sample_id ON sample.sample_predictors (predictor_id);
CREATE TRIGGER tr_sample_predictors_update
    BEFORE UPDATE
    ON sample.sample_predictors
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.project_samples
(
    project_id SMALLINT NOT NULL,
    sample_id  INT      NOT NULL,

    CONSTRAINT pk_project_samples PRIMARY KEY (project_id, sample_id),
    CONSTRAINT fk_projct_samples_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_project_samples_project_id FOREIGN KEY (project_id) REFERENCES sample.projects (project_id) ON DELETE CASCADE
);

/******************************************************************************************************************
 METRIC SCHEMA
 */

CREATE SCHEMA metric;
GRANT USAGE ON SCHEMA metric TO PUBLIC;

CREATE TABLE metric.metric_types
(
    metric_type_id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    type_name      VARCHAR(255) UNIQUE NOT NULL,
    description    TEXT,
    sort_order     SMALLINT UNIQUE     NOT NULL,

    CONSTRAINT ck_metric_types CHECK (sort_order > 0)
);

CREATE TABLE metric.formulae
(
    formula_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name          VARCHAR(255) UNIQUE NOT NULL,
    code_function VARCHAR(100) UNIQUE NOT NULL,
    display_text  TEXT, -- markdown text for reporting
    description   TEXT,

    created_date      TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date      TIMESTAMPTZ         NOT NULL DEFAULT now()
);

CREATE TRIGGER trformulae_update
    BEFORE UPDATE
    ON metric.formulae
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TYPE PERTURBATION_DIRECTIONS AS ENUM ('Increase', 'Decrease', 'Increase or decrease', 'Variable');


CREATE TABLE metric.metrics
(
    metric_id         INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    metric_name       VARCHAR(255) UNIQUE NOT NULL,
    metric_type_id    SMALLINT            NOT NULL,
    translation_id    SMALLINT            NOT NULL,
    formula_id        SMALLINT,
    is_standardized   BOOLEAN,
    perturb_direction PERTURBATION_DIRECTIONS,
    description       TEXT,

    created_date      TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date      TIMESTAMPTZ         NOT NULL DEFAULT now(),

    CONSTRAINT fk_metrics_metric_type_id FOREIGN KEY (metric_type_id) REFERENCES metric.metric_types (metric_type_id),
    CONSTRAINT fk_metrics_translation_id FOREIGN KEY (translation_id) REFERENCES taxa.translations (translation_id) ON DELETE CASCADE,
    CONSTRAINT fk_metrics_formula_id FOREIGN KEY (formula_id) REFERENCES metric.formulae (formula_id)
);
CREATE INDEX fx_metrics_metric_type_id ON metric.metrics (metric_type_id);
CREATE INDEX fx_metrics_formula_id ON metric.formulae (formula_id);

CREATE TRIGGER tr_metrics_update
    BEFORE UPDATE
    ON metric.metrics
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();



CREATE TABLE metric.reports
(
    report_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    report_name  VARCHAR(255) UNIQUE NOT NULL,
    description  TEXT,
    is_active    BOOLEAN             NOT NULL DEFAULT TRUE,
    created_date TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ         NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_reports_update
    BEFORE UPDATE
    ON metric.reports
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


-- CREATE TABLE metric.analysis_types
-- (
--     analysis_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--     analysis_type_name VARCHAR(255) UNIQUE NOT NULL,
--     report_id          SMALLINT            NOT NULL,

--     created_date       TIMESTAMPTZ         NOT NULL DEFAULT now(),
--     updated_date       TIMESTAMPTZ         NOT NULL DEFAULT now(),

--     CONSTRAINT fk_analysis_types_report_id FOREIGN KEY (report_id) REFERENCES metric.reports (report_id) ON DELETE CASCADE
-- );
-- CREATE INDEX fx_analysis_types_report_id ON metric.analysis_types (report_id);
-- CREATE TRIGGER tr_analysis_types_update
--     BEFORE UPDATE
--     ON metric.analysis_types
--     FOR EACH ROW
-- EXECUTE PROCEDURE fn_before_update();


CREATE TABLE metric.analyses
(
    analysis_id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- analysis_type_id SMALLINT            NOT NULL,
    analysis_name VARCHAR(255) UNIQUE NOT NULL,
    sort_order    SMALLINT            NOT NULL,
    report_id     SMALLINT            NOT NULL,
    description   TEXT,

    created_date  TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date  TIMESTAMPTZ         NOT NULL DEFAULT now(),

    -- CONSTRAINT fk_analyses_analysis_type_id FOREIGN KEY (analysis_type_id) REFERENCES metric.analysis_types (analysis_type_id),
    CONSTRAINT fk_analyses_report_id FOREIGN KEY (report_id) REFERENCES metric.reports (report_id),
    CONSTRAINT ck_analyses_sort_order CHECK (sort_order > 0)
);
-- CREATE INDEX fx_metric_analyses_analysis_type_id ON metric.analyses (analysis_type_id);
CREATE UNIQUE INDEX ux_metric_analyses_report_id ON metric.analyses (report_id, sort_order);

CREATE TRIGGER tr_analyses_update
    BEFORE UPDATE
    ON metric.analyses
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

/******************************************************************************************************************
 BILLING SCHEMA
 */

CREATE SCHEMA billing;
GRANT USAGE ON SCHEMA billing TO PUBLIC;


CREATE TABLE billing.line_item_types
(
    line_item_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    line_item_type_name VARCHAR(255) UNIQUE NOT NULL,
    is_active           BOOLEAN             NOT NULL DEFAULT TRUE,

    created_date        TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ         NOT NULL DEFAULT now()
);

CREATE TABLE billing.agreement_types
(
    agreement_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    agreement_type_name VARCHAR(255) UNIQUE NOT NULL,
    description         TEXT,
    is_active           BOOLEAN             NOT NULL DEFAULT TRUE,

    created_date        TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ         NOT NULL DEFAULT now()
);


CREATE TABLE billing.agreements
(
    agreement_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    entity_id         SMALLINT    NOT NULL,
    agreement_type_id SMALLINT    NOT NULL,
    a_number          VARCHAR(20),
    start_date        DATE,
    end_date          DATE,
    is_editable       BOOLEAN     NOT NULL DEFAULT TRUE,

    created_date      TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date      TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_agreements_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities (entity_id),
    CONSTRAINT fk_agreements_agreement_type_id FOREIGN KEY (agreement_type_id) REFERENCES billing.agreement_types (agreement_type_id)
);
CREATE INDEX fx_agreements_entity_id ON billing.agreements (entity_id);
CREATE INDEX fx_agreements_agreement_type_id ON billing.agreements (agreement_type_id);

CREATE TABLE billing.agreement_items
(
    agreement_item_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    agreement_id      SMALLINT NOT NULL,
    line_item_type_id SMALLINT NOT NULL,
    units             SMALLINT NOT NULL DEFAULT 0,
    unit_cost         INT      NOT NULL DEFAULT 0,
    description       TEXT,

    CONSTRAINT fk_agreement_items_agreement_id FOREIGN KEY (agreement_id) REFERENCES billing.agreements (agreement_id),
    CONSTRAINT fk_agreement_items_line_item_type_id FOREIGN KEY (line_item_type_id) REFERENCES billing.line_item_types (line_item_type_id),
    CONSTRAINT ck_agreement_items_units CHECK (units >= 0),
    CONSTRAINT ck_agreement_items_unit_cost CHECK (unit_cost >= 0)
);
CREATE UNIQUE INDEX fx_agreement_items_agreement_id ON billing.agreement_items (agreement_id, line_item_type_id);

CREATE TABLE billing.invoices
(
    invoice_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    entity_id       SMALLINT        NOT NULL,
    agreement_id    SMALLINT,
    invoice_date    DATE            NOT NULL,
    due_date        DATE            NOT NULL,
    invoice_number  SMALLINT UNIQUE NOT NULL,
    received_amount INT,
    received_date   DATE,

    created_date    TIMESTAMPTZ     NOT NULL DEFAULT now(),
    updated_date    TIMESTAMPTZ     NOT NULL DEFAULT now(),

    CONSTRAINT fk_invoices_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities (entity_id),
    CONSTRAINT fk_invoices_agreement_id FOREIGN KEY (agreement_id) REFERENCES billing.agreements (agreement_id),
    CONSTRAINT ck_received_amount CHECK (received_amount >= 0),
    CONSTRAINT ck_received_date CHECK (received_date >= invoice_date)
);
CREATE INDEX fx_invoices_entity_id ON billing.invoices (entity_id);
CREATE INDEX fx_invoices_agreement_id ON billing.invoices (agreement_id);

CREATE TABLE billing.invoice_items
(
    invoice_item_id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    invoice_id        SMALLINT NOT NULL,
    line_item_type_id SMALLINT NOT NULL,
    units             SMALLINT NOT NULL DEFAULT 0,
    unit_price        INT      NOT NULL DEFAULT 0,

    CONSTRAINT fk_invoice_items_invoice_id FOREIGN KEY (invoice_id) REFERENCES billing.invoices (invoice_id),
    CONSTRAINT fk_invoice_items_line_item_type_id FOREIGN KEY (line_item_type_id) REFERENCES billing.line_item_types (line_item_type_id),
    CONSTRAINT ck_invoice_items_units CHECK (units >= 0),
    CONSTRAINT ck_invoice_items_unit_price CHECK (unit_price >= 0)
);
CREATE INDEX fx_invoice_items_invoice_id ON billing.invoice_items (invoice_id);
CREATE INDEX fx_invoice_items_line_item_type_id ON billing.invoice_items (line_item_type_id);

CREATE TABLE billing.invoice_boxes
(
    invoice_id SMALLINT NOT NULL,
    box_id     SMALLINT NOT NULL,

    CONSTRAINT pk_invoice_boxes PRIMARY KEY (invoice_id, box_id),
    CONSTRAINT fk_invoice_boxes_invoice_id FOREIGN KEY (invoice_id) REFERENCES billing.invoices (invoice_id),
    CONSTRAINT fk_invoice_boxes_box_id FOREIGN KEY (box_id) REFERENCES sample.boxes (box_id)
);