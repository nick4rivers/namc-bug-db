CREATE EXTENSION postgis;
CREATE EXTENSION tablefunc;


CREATE FUNCTION fn_before_update()
    RETURNS trigger AS
$$
BEGIN
    NEW.updated_date = now();
    RETURN NEW;
END ;
$$
    LANGUAGE 'plpgsql';

/******************************************************************************************************************
 GEO SCHEMA
 */

CREATE SCHEMA geo;
GRANT USAGE ON SCHEMA geo TO PUBLIC;

CREATE TABLE geo.countries
(
    country_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    country_name VARCHAR(50) UNIQUE NOT NULL,
    abbreviation VARCHAR(5)         NOT NULL,
    geom         GEOMETRY(MultiPolygon, 4326),
    created_date TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ        NOT NULL DEFAULT now()
);
CREATE INDEX gx_countries_geom ON geo.countries USING GIST (geom);
CREATE TRIGGER tr_countries_update
    BEFORE UPDATE
    ON geo.countries
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

CREATE TABLE geo.states
(
    state_id     SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    country_id   SMALLINT    NOT NULL,
    state_name   VARCHAR(50) NOT NULL,
    abbreviation VARCHAR(2)  NOT NULL,
    geom         GEOMETRY(MultiPolygon, 4326),
    created_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_states_country_id FOREIGN KEY (country_id) REFERENCES geo.countries (country_id)
);
CREATE INDEX ix_states_country_id ON geo.states (country_id);
CREATE UNIQUE INDEX ux_states_name ON geo.states (country_id, state_name);
CREATE UNIQUE INDEX ux_states_abbreviation ON geo.states (country_id, abbreviation);
CREATE INDEX gx_states_geom ON geo.states USING GIST (geom);
CREATE TRIGGER tr_states_update
    BEFORE UPDATE
    ON geo.states
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.counties
(
    county_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    state_id     SMALLINT     NOT NULL,
    county_name  VARCHAR(255) NOT NULL,
    geom         GEOMETRY(MultiPolygon, 4326),
    created_date TIMESTAMPTZ  NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ  NOT NULL DEFAULT now(),

    CONSTRAINT fk_counties_state_id FOREIGN KEY (state_id) REFERENCES geo.states (state_id)
);
CREATE INDEX ix_counties_state_id ON geo.counties (state_id);
CREATE UNIQUE INDEX ux_counties_name ON geo.counties (state_id, county_name);
CREATE INDEX gx_counties_geom ON geo.counties USING GIST (geom);
CREATE TRIGGER tr_counties_update
    BEFORE UPDATE
    ON geo.counties
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.land_uses
(
    land_use_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    land_use_name VARCHAR(50) UNIQUE NOT NULL,
    is_active     BOOLEAN            NOT NULL DEFAULT TRUE,
    created_date  TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date  TIMESTAMPTZ        NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_land_uses_update
    BEFORE UPDATE
    ON geo.land_uses
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.ecosystems
(
    ecosystem_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ecosystem_name VARCHAR(10) UNIQUE NOT NULL,
    is_active      BOOLEAN            NOT NULL DEFAULT TRUE,
    description    TEXT,
    created_date   TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date   TIMESTAMPTZ        NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_ecosystems_update
    BEFORE UPDATE
    ON geo.ecosystems
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.habitats
(
    habitat_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    habitat_name VARCHAR(50) UNIQUE NOT NULL,
    ecosystem_id SMALLINT           NOT NULL,
    is_active    BOOLEAN            NOT NULL DEFAULT TRUE,
    created_date TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ        NOT NULL DEFAULT now(),

    CONSTRAINT fk_habitats_ecosystem_id FOREIGN KEY (ecosystem_id) REFERENCES geo.ecosystems (ecosystem_id)
);
CREATE INDEX ix_habitats_ecosystem_id ON geo.habitats (ecosystem_id);
CREATE TRIGGER tr_habitats_update
    BEFORE UPDATE
    ON geo.habitats
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.units
(
    unit_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    unit_name    VARCHAR(50) UNIQUE NOT NULL,
    abbreviation VARCHAR(20) UNIQUE NOT NULL,
    description  TEXT,
    created_date TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ        NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_units_update
    BEFORE UPDATE
    ON geo.units
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.systems
(
    system_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    system_name  VARCHAR(20) UNIQUE NOT NULL,
    ecosystem_id SMALLINT           NOT NULL,
    is_active    BOOLEAN            NOT NULL DEFAULT TRUE,
    created_date TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ        NOT NULL DEFAULT now(),

    CONSTRAINT fk_systems_ecosystem_id FOREIGN KEY (ecosystem_id) REFERENCES geo.ecosystems (ecosystem_id)
);
CREATE INDEX ix_systems_ecosystem_id ON geo.systems (ecosystem_id);
CREATE TRIGGER tr_systems_update
    BEFORE UPDATE
    ON geo.systems
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

CREATE TABLE geo.waterbody_types
(
    waterbody_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    waterbody_type_name VARCHAR(255) UNIQUE NOT NULL,
    metadata            JSON
);

-- TODO: table design incomplete
CREATE TABLE geo.sites
(
    site_id           INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    site_name         VARCHAR(50) UNIQUE    NOT NULL,
    system_id         SMALLINT,
    description       TEXT,
    location          GEOMETRY(Point, 4326) NOT NULL,
    catchment         GEOMETRY(MultiPolygon, 4326),
    waterbody_type_id SMALLINT,
    waterbody_code    VARCHAR(100),
    waterbody_name    VARCHAR(255),
    metadata          JSON,
    created_date      TIMESTAMPTZ           NOT NULL DEFAULT now(),
    updated_date      TIMESTAMPTZ           NOT NULL DEFAULT now(),

    CONSTRAINT fk_sites_system_id FOREIGN KEY (system_id) REFERENCES geo.systems (system_id),
    CONSTRAINT fk_sites_waterbody_type_id FOREIGN KEY (waterbody_type_id) REFERENCES geo.waterbody_types (waterbody_type_id)
);
CREATE INDEX gx_sites_location ON geo.sites USING GIST (location);
CREATE INDEX gx_sites_catchment ON geo.sites USING GIST (catchment);
CREATE INDEX fx_sites_system_id ON geo.sites (system_id);
CREATE INDEX fx_sites_waterbody_type_id ON geo.sites (waterbody_type_id);
CREATE TRIGGER tr_sites_update
    BEFORE UPDATE
    ON geo.sites
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

CREATE TABLE geo.site_catchment_history
(
    catchment_id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    site_id      INT                          NOT NULL,
    catchment    GEOMETRY(MultiPolygon, 4326) NOT NULL,
    description  TEXT,
    created_date TIMESTAMPTZ                  NOT NULL DEFAULT now(),

    CONSTRAINT fk_site_catchment_history_site_id FOREIGN KEY (site_id) REFERENCES geo.sites (site_id) ON DELETE CASCADE
);
CREATE INDEX fx_site_catchment_history_site_id ON geo.site_catchment_history (site_id);
CREATE INDEX gx_site_catchment_history_site_id ON geo.site_catchment_history USING GIST (catchment);

CREATE TABLE geo.site_location_history
(
    location_id  INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    site_id      INT                   NOT NULL,
    location     GEOMETRY(Point, 4326) NOT NULL,
    description  TEXT,
    created_date TIMESTAMPTZ           NOT NULL DEFAULT now(),

    CONSTRAINT fk_site_location_history_site_id FOREIGN KEY (site_id) REFERENCES geo.sites (site_id) ON DELETE CASCADE
);
CREATE INDEX fx_site_location_history_site_id ON geo.site_location_history (site_id);
CREATE INDEX gx_site_location_history_site_id ON geo.site_location_history USING GIST (location);

CREATE TABLE geo.predictor_types
(
    predictor_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    predictor_type_name VARCHAR(255) UNIQUE NOT NULL,
    created_date        TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ         NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_predictor_types_update
    BEFORE UPDATE
    ON geo.predictor_types
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.predictors
(
    predictor_id       SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    predictor_name     VARCHAR(255) UNIQUE NOT NULL,
    abbreviation       VARCHAR(25) UNIQUE  NOT NULL,
    unit_id            SMALLINT            NOT NULL,
    predictor_type_id  SMALLINT            NOT NULL,
    description        TEXT,
    metadata           JSON,
    calculation_script VARCHAR(255),
    created_date       TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date       TIMESTAMPTZ         NOT NULL DEFAULT now(),

    CONSTRAINT fk_predictors_unit_id FOREIGN KEY (unit_id) REFERENCES geo.units (unit_id),
    CONSTRAINT fk_predictors_predictor_type_id FOREIGN KEY (predictor_type_id) REFERENCES geo.predictor_types (predictor_type_id)
);
CREATE INDEX fx_predictors_unit_id ON geo.predictors (unit_id);
CREATE INDEX fk_predictors_predictor_type_id ON geo.predictors (predictor_type_id);
CREATE TRIGGER tr_predictors_update
    BEFORE UPDATE
    ON geo.predictors
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

CREATE TABLE geo.models
(
    model_id     SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    model_name   VARCHAR(255) UNIQUE NOT NULL,
    abbreviation VARCHAR(50) UNIQUE NOT NULL,
    is_active    BOOLEAN             NOT NULL DEFAULT TRUE,
    description  TEXT,
    metadata     JSON,
    created_date TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ         NOT NULL DEFAULT now()
);

CREATE TABLE geo.model_predictors
(
    model_id     SMALLINT NOT NULL,
    predictor_id SMALLINT NOT NULL,

    CONSTRAINT pk_model_predictors PRIMARY KEY (model_id, predictor_id),
    CONSTRAINT fk_model_predictors_model_id FOREIGN KEY (model_id) REFERENCES geo.models(model_id) ON DELETE CASCADE,
    CONSTRAINT fk_model_predictors_predictor_id FOREIGN KEY (predictor_id) REFERENCES geo.predictors(predictor_id)
);

CREATE TABLE geo.site_predictors
(
    predictor_id SMALLINT    NOT NULL,
    site_id      INT         NOT NULL,
    metadata     JSON        NOT NULL,
    created_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT pk_site_predictors PRIMARY KEY (predictor_id, site_id, created_date),
    CONSTRAINT fk_site_predictors FOREIGN KEY (predictor_id) REFERENCES geo.predictors (predictor_id),
    CONSTRAINT fk_site_site_id FOREIGN KEY (site_id) REFERENCES geo.sites (site_id)
);
CREATE INDEX fx_site_predictors_site_id ON geo.site_predictors (site_id);
CREATE TRIGGER tr_site_predictors_update
    BEFORE UPDATE
    ON geo.site_predictors
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


/******************************************************************************************************************
 ENTITY SCHEMA
 */

CREATE SCHEMA entity;
GRANT USAGE ON SCHEMA entity TO PUBLIC;

CREATE TABLE entity.entities
(
    entity_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parent_id    SMALLINT,
    address1     VARCHAR(255),
    address2     VARCHAR(255),
    city         VARCHAR(255),
    state_id     SMALLINT,
    country_id   SMALLINT    NOT NULL,
    zip_code     VARCHAR(20),
    phone        VARCHAR(50),
    fax          VARCHAR(50),
    website      VARCHAR(255),
    notes        TEXT,
    metadata     JSON,
    created_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_entities_parent_id FOREIGN KEY (parent_id) REFERENCES entity.entities (entity_id),
    CONSTRAINT fk_entities_state_id FOREIGN KEY (state_id) REFERENCES geo.states (state_id),
    CONSTRAINT fk_entities_country_id FOREIGN KEY (country_id) REFERENCES geo.countries (country_id)
);
CREATE INDEX fx_entities_state_id ON entity.entities (state_id);
CREATE INDEX fx_entities_country_id ON entity.entities (country_id);
CREATE TRIGGER tr_entities_update
    BEFORE UPDATE
    ON entity.entities
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

CREATE TABLE entity.organization_types
(
    organization_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    organization_type_name VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE entity.organizations
(
    entity_id            SMALLINT NOT NULL PRIMARY KEY,
    abbreviation         VARCHAR(50),
    organization_name    VARCHAR(255),
    organization_type_id SMALLINT NOT NULL,
    is_lab               BOOLEAN  NOT NULL DEFAULT FALSE,

    CONSTRAINT fk_organizations_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities (entity_id) ON DELETE CASCADE,
    CONSTRAINT fk_organizations_organization_type_id FOREIGN KEY (organization_type_id) REFERENCES entity.organization_types (organization_type_id)
);
CREATE UNIQUE INDEX ux_organizations_entity_id ON entity.organizations (entity_id);
CREATE INDEX fx_organizations_organization_type_id ON entity.organizations (organization_type_id);


CREATE TABLE entity.individuals
(
    entity_id      SMALLINT    NOT NULL PRIMARY KEY,
    first_name     VARCHAR(50) NOT NULL,
    last_name      VARCHAR(50) NOT NULL,
    initials       VARCHAR(3),
    affiliation_id SMALLINT,
    email          VARCHAR(255),
    title          VARCHAR(255),
    cognito_sub    VARCHAR(255),

    CONSTRAINT fk_individuals_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities (entity_id) ON DELETE CASCADE,
    CONSTRAINT fk_individuals_affiliation_id FOREIGN KEY (affiliation_id) REFERENCES entity.organizations (entity_id)
);
CREATE UNIQUE INDEX ux_individuals_entity_id ON entity.individuals (entity_id);
CREATE INDEX fx_individuals_affiliation_id ON entity.individuals (affiliation_id);


CREATE TABLE entity.roles
(
    role_id     SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    role_name   VARCHAR(255) UNIQUE NOT NULL,
    description TEXT
);

CREATE TABLE entity.individual_roles
(
    entity_id SMALLINT NOT NULL,
    role_id   SMALLINT NOT NULL,

    CONSTRAINT pk_individuals_roles PRIMARY KEY (entity_id, role_id),
    CONSTRAINT fk_individual_roles_entity_id FOREIGN KEY (entity_id) REFERENCES entity.individuals (entity_id) ON DELETE CASCADE,
    CONSTRAINT fk_individual_roles_role_id FOREIGN KEY (role_id) REFERENCES entity.roles (role_id)
);


CREATE TABLE entity.communications
(
    history_id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    entity_id    SMALLINT,
    employee_id  SMALLINT    NOT NULL,
    notes        TEXT,
    metadata     JSON,
    created_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_history_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities (entity_id),
    CONSTRAINT fk_history_namc_staff_id FOREIGN KEY (employee_id) REFERENCES entity.individuals (entity_id)
);
CREATE INDEX fx_entities_history_entity_id ON entity.communications (entity_id);
CREATE INDEX fx_entities_history_employee_id ON entity.communications (employee_id);


CREATE TABLE entity.lab_types
(
    lab_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    lab_type_name VARCHAR(255) UNIQUE NOT NULL
);

/******************************************************************************************************************
 Taxa SCHEMA
 */

CREATE SCHEMA taxa;
GRANT USAGE ON SCHEMA taxa TO PUBLIC;

CREATE TABLE taxa.taxa_levels
(
    level_id        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    level_name      VARCHAR(50) UNIQUE NOT NULL,
    parent_level_id SMALLINT UNIQUE,
    is_active       BOOLEAN            NOT NULL DEFAULT TRUE,
    description     TEXT,

    CONSTRAINT fk_taxa_levels_parent_level_id FOREIGN KEY (parent_level_id) REFERENCES taxa.taxa_levels (level_id)
);

CREATE TABLE taxa.life_stages
(
    life_stage_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    abbreviation    CHAR(1) UNIQUE     NOT NULL,
    life_stage_name VARCHAR(50) UNIQUE NOT NULL,
    is_active       BOOLEAN            NOT NULL DEFAULT TRUE
);

CREATE TABLE taxa.taxonomy
(
    taxonomy_id     SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    scientific_name VARCHAR(255) NOT NULL,
    level_id        SMALLINT     NOT NULL,
    parent_id       SMALLINT,
    author          VARCHAR(255),
    year            SMALLINT,
    created_date    TIMESTAMPTZ  NOT NULL DEFAULT now(),
    updated_date    TIMESTAMPTZ  NOT NULL DEFAULT now(),

    CONSTRAINT fk_organism_taxonomy_taxa_level_id FOREIGN KEY (level_id) REFERENCES taxa.taxa_levels (level_id)
);
CREATE INDEX fx_organism_taxonomy_taxa_level_id ON taxa.taxonomy (level_id);
CREATE TRIGGER tr_taxonomy_update
    BEFORE UPDATE
    ON taxa.taxonomy
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE taxa.synonyms
(
    synonym_id  SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    taxonomy_id SMALLINT     NOT NULL,
    synonym     VARCHAR(255) NOT NULL,

    CONSTRAINT fk_synonyms_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy (taxonomy_id) ON DELETE CASCADE
);
CREATE INDEX fx_synonyms_taxonomy_id ON taxa.synonyms (taxonomy_id);

CREATE TYPE ATTRIBUTE_TYPES AS ENUM ('Float', 'Integer', 'Text', 'Unknown');


CREATE TABLE taxa.attributes
(
    attribute_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    attribute_name VARCHAR(255) UNIQUE NOT NULL,
    attribute_type ATTRIBUTE_TYPES     NOT NULL,
    label          VARCHAR(255),
    description    TEXT,
    metadata       JSON,

    created_date   TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date   TIMESTAMPTZ         NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_attributes_update
    BEFORE UPDATE
    ON taxa.attributes
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE taxa.taxa_attributes
(
    taxonomy_id     SMALLINT     NOT NULL,
    attribute_id    SMALLINT     NOT NULL,
    attribute_value VARCHAR(100) NOT NULL,

    CONSTRAINT pk_taxa_attributes PRIMARY KEY (taxonomy_id, attribute_id),
    CONSTRAINT fk_taxa_attributes_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy (taxonomy_id) ON DELETE CASCADE,
    CONSTRAINT fk_taxa_attributes_attribute_id FOREIGN KEY (attribute_id) REFERENCES taxa.attributes (attribute_id)
);

/*
 ITIS
 Encyc of Life
 Wiki Species
 */
CREATE TABLE taxa.external_sources
(
    source_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    source_name  VARCHAR(255) UNIQUE NOT NULL,
    abbreviation VARCHAR(10) UNIQUE  NOT NULL,
    description  TEXT,
    metadata     JSONB
);


CREATE TABLE taxa.external_ids
(
    source_id          SMALLINT NOT NULL,
    taxonomy_id        SMALLINT NOT NULL,
    external_source_id VARCHAR(255),
    scientific_name    VARCHAR(255),

    CONSTRAINT pk_external_ids PRIMARY KEY (source_id, taxonomy_id),
    CONSTRAINT fk_external_ids_source_id FOREIGN KEY (source_id) REFERENCES taxa.external_sources (source_id) ON DELETE CASCADE,
    CONSTRAINT fk_external_ids_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy (taxonomy_id)
);


CREATE TABLE taxa.translations
(
    translation_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    translation_name VARCHAR(255) UNIQUE NOT NULL,
    description      TEXT,
    is_active        BOOLEAN             NOT NULL DEFAULT TRUE,

    created_date     TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date     TIMESTAMPTZ         NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_translations_update
    BEFORE UPDATE
    ON taxa.translations
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE taxa.taxa_translations
(
    translation_id          SMALLINT NOT NULL,
    taxonomy_id             SMALLINT NOT NULL,
    translation_taxonomy_id SMALLINT NOT NULL,

    CONSTRAINT pk_taxa_translations PRIMARY KEY (translation_id, taxonomy_id),
    CONSTRAINT fk_taxa_translations_translation_id FOREIGN KEY (translation_id) REFERENCES taxa.translations (translation_id) ON DELETE CASCADE,
    CONSTRAINT fk_taxa_translations_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy (taxonomy_id),
    CONSTRAINT fk_taxa_translation_translation_taxonomy_id FOREIGN KEY (translation_taxonomy_id) REFERENCES taxa.taxonomy (taxonomy_id)
);
CREATE INDEX fx_taxa_translations_taxonomy_id ON taxa.taxa_translations (taxonomy_id);
CREATE INDEX fx_taxa_translations_translation_taxonomy_id ON taxa.taxa_translations (translation_taxonomy_id);

CREATE TABLE taxa.translation_predictors
(
    translation_id SMALLINT NOT NULL,
    predictor_id   SMALLINT NOT NULL,

    CONSTRAINT pk_taxa_translation_predictors PRIMARY KEY (translation_id, predictor_id),
    CONSTRAINT fk_taxa_translation_predictors_translation_id FOREIGN KEY (translation_id) REFERENCES taxa.translations (translation_id) ON DELETE CASCADE,
    CONSTRAINT fk_taxa_translation_predictors_predictor_id FOREIGN KEY (predictor_id) REFERENCES geo.predictors (predictor_id)
);

/******************************************************************************************************************
 SAMPLE SCHEMA
 */

CREATE SCHEMA sample;
GRANT USAGE ON SCHEMA sample TO PUBLIC;

CREATE TABLE sample.sample_methods
(
    sample_method_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_method_name VARCHAR(50) UNIQUE NOT NULL,
    is_active          BOOLEAN            NOT NULL DEFAULT TRUE,
    created_date       TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date       TIMESTAMPTZ        NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_sample_methods_update
    BEFORE UPDATE
    ON sample.sample_methods
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.sample_types
(
    sample_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_type_name VARCHAR(50) UNIQUE NOT NULL,
    is_active        BOOLEAN            NOT NULL DEFAULT TRUE,
    created_date     TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date     TIMESTAMPTZ        NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_sample_types
    BEFORE UPDATE
    ON sample.sample_types
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.box_states
(
    box_state_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    box_state_name  VARCHAR(50) UNIQUE NOT NULL,
    box_state_order SMALLINT UNIQUE    NOT NULL,
    description     TEXT,
    is_active       BOOLEAN            NOT NULL DEFAULT TRUE,

    CONSTRAINT chk_box_states CHECK (box_state_order > 0)
);

CREATE TABLE sample.project_types
(
    project_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    project_type_name VARCHAR(255) UNIQUE NOT NULL,
    description       TEXT,
    is_active         BOOLEAN             NOT NULL DEFAULT TRUE
);

CREATE TABLE sample.projects
(
    project_id          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    project_name        VARCHAR(255) UNIQUE NOT NULL,
    project_type_id     SMALLINT            NOT NULL,
    is_private          BOOLEAN                      DEFAULT TRUE,
    contact_id          SMALLINT,
    extent              GEOMETRY(MultiPolygon, 4326),
    auto_update_samples BOOLEAN             NOT NULL DEFAULT FALSE,
    description         TEXT,
    metadata            JSON,
    created_date        TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ         NOT NULL DEFAULT now(),

    CONSTRAINT fk_projects_contact_id FOREIGN KEY (contact_id) REFERENCES entity.entities (entity_id),
    CONSTRAINT fk_projects_project_type_id FOREIGN KEY (project_type_id) REFERENCES sample.project_types (project_type_id)
);
CREATE INDEX fx_projects_contact_id ON sample.projects (contact_id);
CREATE INDEX fx_projects_project_type_id ON sample.projects (project_type_id);
CREATE INDEX gx_projects_extent ON sample.projects USING GIST (extent);
CREATE TRIGGER tr_projects_update
    BEFORE UPDATE
    ON sample.projects
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


-- TODO: table design incomplete
-- TODO: review columns copied from PilotDB.BugTacking
-- TODO: UsuTrack changed from FLOAT to SMALLINT
-- TODO: hook up billing_cust_id to customers? Confirm purpose
-- TODO: Default icost and tcost to zero?
-- TODO: add sort_time and id_time as summary columns on view
CREATE TABLE sample.boxes
(
    box_id                   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_id              SMALLINT    NOT NULL,
    submitter_id             SMALLINT    NOT NULL,
    box_state_id             SMALLINT    NOT NULL,
    box_recevied_date        TIMESTAMPTZ,                        -- date the box arrives
    processing_complete_date TIMESTAMPTZ,                        -- date lab processing is complete
    projected_complete_date  TIMESTAMPTZ,                        -- report_ready, available to customer, customer notified. all data QAed.
    description              TEXT,
    metadata                 JSON,
    measurements             BOOLEAN     NOT NULL DEFAULT FALSE, -- things customers can be billed for (fee per sample) checkbox in submission UI
    sorter_qa                BOOLEAN     NOT NULL DEFAULT FALSE, -- things customers can be billed for (fee per sample) checkbox in submission UI
    taxa_qa                  BOOLEAN     NOT NULL DEFAULT FALSE, -- things customers can be billed for (fee per sample) checkbox in submission UI
    created_date             TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date             TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_boxes_customer_id FOREIGN KEY (customer_id) REFERENCES entity.entities (entity_id),
    CONSTRAINT fk_boxes_creator_id FOREIGN KEY (submitter_id) REFERENCES entity.individuals (entity_id),
    CONSTRAINT fk_boxes_state_id FOREIGN KEY (box_state_id) REFERENCES sample.box_states (box_state_id)
);
CREATE INDEX fx_boxes_customer_id ON sample.boxes (customer_id);
CREATE INDEX fx_boxes_status_id ON sample.boxes (box_state_id);
CREATE TRIGGER tr_boxes_update
    BEFORE UPDATE
    ON sample.boxes
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

-- TODO: Should this table have it's own primary key so that it can
-- store each version of the submission should it be edited by NAMC
-- after it is submitted. It must be possible to always find the latest
-- version either using the created_date or the largest primary key.
-- sample records do not get created until pending QA process is
-- completed.

CREATE TABLE sample.submissions
(
    submission_id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    box_id          INT         NOT NULL,
    version_id      INT         NOT NULL,
    metadata        JSONB       NOT NULL,
    submitted_by_id SMALLINT    NOT NULL,
    created_date    TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date    TIMESTAMPTZ NOT NULL DEFAULT now(),


    CONSTRAINT fk_submissions_box_id FOREIGN KEY (box_id) REFERENCES sample.boxes (box_id) ON DELETE CASCADE,
    CONSTRAINT fk_submissions_submitted_by_id FOREIGN KEY (submitted_by_id) REFERENCES entity.individuals (entity_id)

);
CREATE UNIQUE INDEX ux_submissions_box_id ON sample.submissions (box_id, version_id);
CREATE INDEX fx_submissions_submitted_by_id ON sample.submissions (submitted_by_id);
CREATE TRIGGER tr_sumbissions_update
    BEFORE UPDATE
    ON sample.submissions
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


-- TODO: Verify that it's OK to make qualitative NOT NULL and check what the default should be
-- TODO: verify that Count field is not needed?
-- TODO: verify that SorterChironomidae is needed?
-- TODO: what is the field PilotDB.BugSample.MainID?
-- TODO: what is the field PilotDB.BugSample.Replicates?
-- TODO: what is the field PilotDB.BugSample.Archive?
-- TODO: I have converted mesh FROM FLOAT to SMALLINT. OK? Values are 56, 120, 180, 425
-- Jar count is the initial number of jars that the customer sends for each sample
CREATE TABLE sample.samples (
    sample_id           INT GENERATED BY DEFAULT AS IDENTITY,
    box_id              INT NOT NULL,
    site_id             INT,
    visit_id            VARCHAR(100),
    location            GEOMETRY(Point, 4326), -- NOT NULL,
    sample_date         DATE,
    sample_time         TIME,
    type_id             SMALLINT NOT NULL,
    method_id           SMALLINT NOT NULL,
    habitat_id          SMALLINT NOT NULL,
    area                REAL,
    field_split         REAL, -- big sample... in the field keep only 50% or 25% (not submitting the bit they don't keep)
    field_notes         TEXT,
    lab_split           REAL, -- lab puts all sample in bucket and sorts 25% or 50%
    jar_count           SMALLINT NOT NULL DEFAULT 1, -- lab person verifies the jars match the number in the submission form.
    qualitative         BOOLEAN DEFAULT FALSE,
    lab_notes           TEXT,
    mesh                SMALLINT,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    qa_sample_id        SMALLINT,
    metadata            JSON,

    CONSTRAINT pk_samples PRIMARY KEY (sample_id),
    CONSTRAINT fk_samples_box_id FOREIGN KEY (box_id) REFERENCES sample.boxes (box_id) ON DELETE CASCADE,
    CONSTRAINT fk_samples_site_id FOREIGN KEY (site_id) REFERENCES geo.sites (site_id),
    CONSTRAINT fk_samples_type_id FOREIGN KEY (type_id) REFERENCES sample.sample_types (sample_type_id),
    CONSTRAINT fk_samples_method_id FOREIGN KEY (method_id) REFERENCES sample.sample_methods (sample_method_id),
    CONSTRAINT fk_samples_habitat_id FOREIGN KEY (habitat_id) REFERENCES geo.habitats (habitat_id),
    CONSTRAINT ck_samples_area CHECK (area >= 0),
    CONSTRAINT ck_samples_field_split CHECK (field_split >= 0),
    CONSTRAINT ck_samples_lab_split CHECK (lab_split >= 0),
    CONSTRAINT chk_samples_mesh CHECK (mesh > 0),
    CONSTRAINT chk_samples_jar_count CHECK (jar_count > 0)
);
CREATE INDEX fx_samples_box_id ON sample.samples (box_id);
CREATE INDEX fx_samples_site_id ON sample.samples (site_id);
CREATE INDEX fx_samples_visit_id ON sample.samples (visit_id);
CREATE INDEX gx_samples_location ON sample.samples USING GIST (location);
CREATE INDEX fx_samples_type_id ON sample.samples (type_id);
CREATE INDEX fx_samples_method_id ON sample.samples (method_id);
CREATE INDEX fx_samples_habitat_id ON sample.samples (habitat_id);
CREATE TRIGGER tr_samples_update
    BEFORE UPDATE
    ON sample.samples
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.sorter_time
(
    sorter_time_id  INT      NOT NULL GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_id       INT      NOT NULL,
    sorter_id       SMALLINT NOT NULL,
    sorter_count    SMALLINT,
    elutriation     BOOLEAN  NOT NULL DEFAULT FALSE,
    sort_time       REAL     NOT NULL DEFAULT 0,
    sort_start_date TIMESTAMPTZ,
    sort_end_date   TIMESTAMPTZ,
    is_qa           BOOLEAN  NOT NULL DEFAULT FALSE,

    CONSTRAINT fk_sorter_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id),
    CONSTRAINT fk_sorter_sorter_id FOREIGN KEY (sorter_id) REFERENCES entity.individuals (entity_id),
    CONSTRAINT ck_sorter_sorter_count CHECK (sorter_count >= 0)
);
CREATE INDEX fx_sorter_time_sample_id ON sample.sorter_time (sample_id);
CREATE INDEX fx_sorter_time_sorter_id ON sample.sorter_time (sorter_id);


CREATE TABLE sample.taxa_time
(
    taxa_time_id  INT  NOT NULL GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_id     INT  NOT NULL,
    id_er         INT  NOT NULL,
    id_time       REAL NOT NULL DEFAULT 0,
    id_start_date timestamptz,
    id_end_date   timestamptz,

    CONSTRAINT fk_taxa_time_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id),
    CONSTRAINT fk_taxa_time_id_ier FOREIGN KEY (id_er) REFERENCES entity.individuals (entity_id)
);
CREATE INDEX fx_taxa_time_sample_id ON sample.taxa_time (sample_id);
CREATE INDEX fx_taxa_time_id_er ON sample.taxa_time (id_er);


CREATE TABLE sample.sample_labs
(
    sample_id   INT      NOT NULL,
    entity_id   SMALLINT NOT NULL,
    lab_type_id SMALLINT NOT NULL,

    CONSTRAINT pk_sample_labs PRIMARY KEY (sample_id, entity_id, lab_type_id),
    CONSTRAINT fk_sample_labs_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_sample_labs_entity_id FOREIGN KEY (entity_id) REFERENCES entity.organizations (entity_id),
    CONSTRAINT fk_sample_labs_lab_type_id FOREIGN KEY (lab_type_id) REFERENCES entity.lab_types (lab_type_id)
);


CREATE TYPE TOW_TYPES AS ENUM ('Vertical', 'Horizontal');

CREATE TABLE sample.plankton
(
    sample_id        INT         NOT NULL PRIMARY KEY,
    diameter         REAL,
    sub_sample_count SMALLINT,
    tow_length       REAL,
    volume           REAL,
    aliquot          REAL,
    size_interval    REAL,
    tow_type         TOW_TYPES,
    notes            TEXT,
    updated_date     TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_plankton_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT ck_plankton_diameter CHECK (diameter > 0),
    CONSTRAINT ck_plankton_sub_sample_count CHECK (sub_sample_count >= 0),
    CONSTRAINT ck_plankton_tow_length CHECK (tow_length > 0),
    CONSTRAINT ck_plankton_volume CHECK (volume > 0),
    CONSTRAINT ck_plankton_size_interval CHECK (size_interval > 0)
);
CREATE TRIGGER tr_plankton_update
    BEFORE UPDATE
    ON sample.plankton
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

/*
 used to be net diameter - meaningless for rectangular nets.

 metrics work off of volumes. So need to get the diameters into areas
 */
CREATE TABLE sample.drift
(
    sample_id    INT         NOT NULL PRIMARY KEY,
    net_area     FLOAT,
    net_duration FLOAT,
    stream_depth FLOAT,
    net_depth    FLOAT,
    net_velocity FLOAT,
    notes        TEXT,
    updated_date TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT ck_bug_drift_net_area CHECK (net_area > 0),
    CONSTRAINT ck_bug_drift_net_duration CHECK (net_duration > 0),
    CONSTRAINT ck_bug_drift_stream_depth CHECK (stream_depth > 0),
    CONSTRAINT ck_bug_drift_net_depth CHECK (net_depth > 0),
    CONSTRAINT ck_bug_drift_net_velocity CHECK (net_velocity >= 0)
);
CREATE TRIGGER tr_drift_update
    BEFORE UPDATE
    ON sample.drift
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

CREATE TABLE sample.mass_methods
(
    mass_method_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    mass_method_name VARCHAR(255) UNIQUE NOT NULL,
    abbreviation     VARCHAR(15) UNIQUE  NOT NULL,
    is_active        BOOLEAN             NOT NULL DEFAULT TRUE
);

CREATE TABLE sample.mass_types
(
    mass_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    mass_type_name VARCHAR(255) UNIQUE NOT NULL,
    abbreviation   VARCHAR(15) UNIQUE  NOT NULL,
    is_active      BOOLEAN             NOT NULL DEFAULT TRUE
);

/*
 AFDM = Ash free dry mass
 The old bug o matter table used to have AFDM column. IT was a sum of several
 different kinds of mass.
 */
CREATE TABLE sample.mass
(
    sample_id      INT         NOT NULL,
    mass_type_id   SMALLINT    NOT NULL,
    mass_method_id SMALLINT    NOT NULL,
    mass           REAL        NOT NULL,
    notes          TEXT,
    updated_date   TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT pk_mass PRIMARY KEY (sample_id, mass_type_id),
    CONSTRAINT fk_mass_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_mass_mass_type_id FOREIGN KEY (mass_type_id) REFERENCES sample.mass_types (mass_type_id),
    CONSTRAINT fk_mass_method_id FOREIGN KEY (mass_method_id) REFERENCES sample.mass_methods (mass_method_id)
);
CREATE INDEX fx_mass_type_id ON sample.mass (mass_type_id);
CREATE INDEX fx_mass_method_id ON sample.mass (mass_method_id);
CREATE TRIGGER tr_mass_update
    BEFORE UPDATE
    ON sample.mass
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

-- BugOMatter table
-- not all records are AFDM. The type
CREATE TABLE sample.taxa_mass
(
    sample_id      INT      NOT NULL,
    taxa_id        SMALLINT NOT NULL,
    mass_type_id   SMALLINT NOT NULL,
    mass_method_id SMALLINT NOT NULL,
    mass           REAL     NOT NULL,
    notes          TEXT
);

-- TODO PilotDB.Stomachs.Code is NULL and the species column has species as text
CREATE TABLE sample.fish
(
    sample_id    INT         NOT NULL PRIMARY KEY,
    taxonomy_id  SMALLINT    NOT NULL,
    fish_length  REAL,
    fish_mass    REAL,
    notes        TEXT,
    updated_date TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_fish_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_fish_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy (taxonomy_id),
    CONSTRAINT ck_fish_fish_length CHECK (fish_length >= 0),
    CONSTRAINT ck_fish_fish_mass CHECK (fish_mass >= 0)
);
CREATE INDEX fish_taxa_id ON sample.fish (taxonomy_id);
CREATE TRIGGER tr_fish_update
    BEFORE UPDATE
    ON sample.fish
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

/*
 metadata key "pre_reconciliation_taxonomy_id" is the
 taxonomy_id before the taxonomic reconciliation process.

 We don't want to store multiple records for the same
 organism, distinguished by some "valid/invalid" flag
 for fear that users will forget to filter by this flag.
 */
CREATE TABLE sample.organisms
(
    organism_id      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_id        INT         NOT NULL,
    taxonomy_id      SMALLINT    NOT NULL,
    life_stage_id    SMALLINT    NOT NULL,
    bug_size         REAL,
    split_count      REAL,
    big_rare_count   SMALLINT,
    metadata         JSON,
    notes            TEXT,
    created_date     TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date     TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_organisms_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_organisms_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy (taxonomy_id),
    CONSTRAINT fk_organisms_life_stage_id FOREIGN KEY (life_stage_id) REFERENCES taxa.life_stages (life_stage_id)
);
CREATE UNIQUE INDEX ux_organism_organisms ON sample.organisms(sample_id, taxonomy_id, life_stage_id, bug_size);
CREATE INDEX fx_organisms_taxonomy_id ON sample.organisms(taxonomy_id);
CREATE INDEX fx_organisms_life_stage_id ON sample.organisms(life_stage_id);
CREATE TRIGGER tr_organisms_update
    BEFORE UPDATE
    ON sample.organisms
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();



CREATE TABLE sample.note_types
(
    note_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    note_name    VARCHAR(25) UNIQUE NOT NULL,
    abbreviation CHAR(1) UNIQUE     NOT NULL,
    description  TEXT,
    is_active    BOOLEAN            NOT NULL DEFAULT TRUE,

    created_date TIMESTAMPTZ        NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ        NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_note_types_update
    BEFORE UPDATE
    ON sample.note_types
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.organism_notes
(
    organism_id INT      NOT NULL,
    note_id     SMALLINT NOT NULL,

    CONSTRAINT pk_organism_types PRIMARY KEY (organism_id, note_id),
    CONSTRAINT fk_organism_types_organism_id FOREIGN KEY (organism_id) REFERENCES sample.organisms (organism_id) ON DELETE CASCADE,
    CONSTRAINT fk_organism_types_note_id FOREIGN KEY (note_id) REFERENCES sample.note_types (note_id)
);

-- TODO: would this table be better named as sample.asset_types
CREATE TABLE sample.asset_types
(
    asset_type_id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    asset_name    VARCHAR(255) NOT NULL UNIQUE,
    description   TEXT,
    is_active     BOOLEAN      NOT NULL DEFAULT TRUE,

    created_date  TIMESTAMPTZ  NOT NULL DEFAULT now(),
    updated_date  TIMESTAMPTZ  NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_asset_types_update
    BEFORE UPDATE
    ON sample.asset_types
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

CREATE TABLE sample.assets
(
    asset_id      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    asset_type_id SMALLINT            NOT NULL,
    uuid          VARCHAR(255) UNIQUE NOT NULL,
    created_date  TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date  TIMESTAMPTZ         NOT NULL DEFAULT now(),

    CONSTRAINT fk_sample_assets_asset_type_id FOREIGN KEY (asset_type_id) REFERENCES sample.asset_types (asset_type_id)
);
CREATE INDEX fx_sample_assets_asset_type_id ON sample.assets (asset_type_id);
CREATE INDEX fx_sample_assets_uuid ON sample.assets (uuid);

CREATE TABLE sample.sample_assets
(
    sample_id    INT         NOT NULL,
    asset_id     INT         NOT NULL,
    created_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT pk_sample_assets PRIMARY KEY (sample_id, asset_id),
    CONSTRAINT fk_sample_assets_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_sample_assets_asset_id FOREIGN KEY (asset_id) REFERENCES sample.assets (asset_id)
);


CREATE TABLE sample.box_assets
(
    box_id       INT         NOT NULL,
    asset_id     INT         NOT NULL,
    created_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT pk_sample_box_assets PRIMARY KEY (box_id, asset_id),
    CONSTRAINT fk_sample_box_assets_box_id FOREIGN KEY (box_id) REFERENCES sample.boxes (box_id),
    CONSTRAINT fk_sample_box_assets_asset_id FOREIGN KEY (asset_id) REFERENCES sample.assets (asset_id)
);

CREATE TABLE sample.sample_predictors
(
    sample_id    INT         NOT NULL,
    predictor_id SMALLINT    NOT NULL,
    metadata     JSONB,
    created_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT pk_sample_predictors PRIMARY KEY (sample_id, predictor_id, created_date),
    CONSTRAINT fk_sample_predictors_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_sample_predictors_predictor_id FOREIGN KEY (predictor_id) REFERENCES geo.predictors (predictor_id) ON DELETE CASCADE
);
CREATE INDEX fx_sample_predictors_sample_id ON sample.sample_predictors (predictor_id);
CREATE TRIGGER tr_sample_predictors_update
    BEFORE UPDATE
    ON sample.sample_predictors
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.project_samples
(
    project_id SMALLINT NOT NULL,
    sample_id  INT      NOT NULL,

    CONSTRAINT pk_project_samples PRIMARY KEY (project_id, sample_id),
    CONSTRAINT fk_projct_samples_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_project_samples_project_id FOREIGN KEY (project_id) REFERENCES sample.projects (project_id) ON DELETE CASCADE
);

/******************************************************************************************************************
 METRIC SCHEMA
 */

CREATE SCHEMA metric;
GRANT USAGE ON SCHEMA metric TO PUBLIC;

CREATE TABLE metric.metric_types
(
    metric_type_id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    metric_name    VARCHAR(255) UNIQUE NOT NULL,
    description    TEXT,
    unit_id        SMALLINT            NOT NULL,

    created_date   TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date   TIMESTAMPTZ         NOT NULL DEFAULT now(),

    CONSTRAINT fk_metric_types_unit_id FOREIGN KEY (unit_id) REFERENCES geo.units (unit_id)
);
CREATE INDEX fx_metric_types_unit_id ON metric.metric_types (unit_id);
CREATE TRIGGER tr_metric_types_update
    BEFORE UPDATE
    ON metric.metric_types
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE metric.metrics
(
    metric_id      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_id      INT      NOT NULL,
    metric_type_id SMALLINT NOT NULL,
    translation_id SMALLINT NOT NULL,

    CONSTRAINT fk_metrics_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples (sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_metrics_metric_type_id FOREIGN KEY (metric_type_id) REFERENCES metric.metric_types (metric_type_id),
    CONSTRAINT fk_metrics_translation_id FOREIGN KEY (translation_id) REFERENCES taxa.translations (translation_id) ON DELETE CASCADE
);
CREATE INDEX fx_metrics_metric_type_id ON metric.metrics (metric_type_id);
CREATE TRIGGER tr_metrics_update
    BEFORE UPDATE
    ON metric.metrics
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE metric.reports
(
    report_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    report_name  VARCHAR(255) UNIQUE NOT NULL,
    description  TEXT,
    is_active    BOOLEAN             NOT NULL DEFAULT TRUE,

    created_date TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date TIMESTAMPTZ         NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_reports_update
    BEFORE UPDATE
    ON metric.reports
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE metric.analysis_types
(
    analysis_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    analysis_type_name VARCHAR(255) UNIQUE NOT NULL,
    report_id          SMALLINT            NOT NULL,

    created_date       TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date       TIMESTAMPTZ         NOT NULL DEFAULT now(),

    CONSTRAINT fk_analysis_types_report_id FOREIGN KEY (report_id) REFERENCES metric.reports (report_id) ON DELETE CASCADE
);
CREATE INDEX fx_analysis_types_report_id ON metric.analysis_types (report_id);
CREATE TRIGGER tr_analysis_types_update
    BEFORE UPDATE
    ON metric.analysis_types
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();


CREATE TABLE metric.analyses
(
    analysis_id      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    analysis_type_id SMALLINT    NOT NULL,

    created_date     TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date     TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_analyses_analysis_type_id FOREIGN KEY (analysis_id) REFERENCES metric.analysis_types (analysis_type_id)
);
CREATE TRIGGER tr_analyses_update
    BEFORE UPDATE
    ON metric.analyses
    FOR EACH ROW
EXECUTE PROCEDURE fn_before_update();

/******************************************************************************************************************
 BILLING SCHEMA
 */

CREATE SCHEMA billing;
GRANT USAGE ON SCHEMA billing TO PUBLIC;


CREATE TABLE billing.line_item_types
(
    line_item_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    line_item_type_name VARCHAR(255) UNIQUE NOT NULL,
    is_active           BOOLEAN             NOT NULL DEFAULT TRUE,

    created_date        TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ         NOT NULL DEFAULT now()
);

CREATE TABLE billing.agreement_types
(
    agreement_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    agreement_type_name VARCHAR(255) UNIQUE NOT NULL,
    description         TEXT,
    is_active           BOOLEAN             NOT NULL DEFAULT TRUE,

    created_date        TIMESTAMPTZ         NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ         NOT NULL DEFAULT now()
);


CREATE TABLE billing.agreements
(
    agreement_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    entity_id         SMALLINT    NOT NULL,
    agreement_type_id SMALLINT    NOT NULL,
    a_number          VARCHAR(20),
    start_date        DATE,
    end_date          DATE,
    is_editable       BOOLEAN     NOT NULL DEFAULT TRUE,

    created_date      TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date      TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_agreements_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities (entity_id),
    CONSTRAINT fk_agreements_agreement_type_id FOREIGN KEY (agreement_type_id) REFERENCES billing.agreement_types (agreement_type_id)
);
CREATE INDEX fx_agreements_entity_id ON billing.agreements (entity_id);
CREATE INDEX fx_agreements_agreement_type_id ON billing.agreements (agreement_type_id);

CREATE TABLE billing.agreement_items
(
    agreement_item_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    agreement_id      SMALLINT NOT NULL,
    line_item_type_id SMALLINT NOT NULL,
    units             SMALLINT NOT NULL DEFAULT 0,
    unit_cost         INT      NOT NULL DEFAULT 0,
    description       TEXT,

    CONSTRAINT fk_agreement_items_agreement_id FOREIGN KEY (agreement_id) REFERENCES billing.agreements (agreement_id),
    CONSTRAINT fk_agreement_items_line_item_type_id FOREIGN KEY (line_item_type_id) REFERENCES billing.line_item_types (line_item_type_id),
    CONSTRAINT ck_agreement_items_units CHECK (units >= 0),
    CONSTRAINT ck_agreement_items_unit_cost CHECK (unit_cost >= 0)
);
CREATE UNIQUE INDEX fx_agreement_items_agreement_id ON billing.agreement_items (agreement_id, line_item_type_id);

CREATE TABLE billing.invoices
(
    invoice_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    entity_id       SMALLINT        NOT NULL,
    agreement_id    SMALLINT,
    invoice_date    DATE            NOT NULL,
    due_date        DATE            NOT NULL,
    invoice_number  SMALLINT UNIQUE NOT NULL,
    received_amount INT,
    received_date   DATE,

    created_date    TIMESTAMPTZ     NOT NULL DEFAULT now(),
    updated_date    TIMESTAMPTZ     NOT NULL DEFAULT now(),

    CONSTRAINT fk_invoices_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities (entity_id),
    CONSTRAINT fk_invoices_agreement_id FOREIGN KEY (agreement_id) REFERENCES billing.agreements (agreement_id),
    CONSTRAINT ck_received_amount CHECK (received_amount >= 0),
    CONSTRAINT ck_received_date CHECK (received_date >= invoice_date)
);
CREATE INDEX fx_invoices_entity_id ON billing.invoices (entity_id);
CREATE INDEX fx_invoices_agreement_id ON billing.invoices (agreement_id);

CREATE TABLE billing.invoice_items
(
    invoice_item_id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    invoice_id        SMALLINT NOT NULL,
    line_item_type_id SMALLINT NOT NULL,
    units             SMALLINT NOT NULL DEFAULT 0,
    unit_price        INT      NOT NULL DEFAULT 0,

    CONSTRAINT fk_invoice_items_invoice_id FOREIGN KEY (invoice_id) REFERENCES billing.invoices (invoice_id),
    CONSTRAINT fk_invoice_items_line_item_type_id FOREIGN KEY (line_item_type_id) REFERENCES billing.line_item_types (line_item_type_id),
    CONSTRAINT ck_invoice_items_units CHECK (units >= 0),
    CONSTRAINT ck_invoice_items_unit_price CHECK (unit_price >= 0)
);
CREATE INDEX fx_invoice_items_invoice_id ON billing.invoice_items (invoice_id);
CREATE INDEX fx_invoice_items_line_item_type_id ON billing.invoice_items (line_item_type_id);

CREATE TABLE billing.invoice_boxes
(
    invoice_id SMALLINT NOT NULL,
    box_id     SMALLINT NOT NULL,

    CONSTRAINT pk_invoice_boxes PRIMARY KEY (invoice_id, box_id),
    CONSTRAINT fk_invoice_boxes_invoice_id FOREIGN KEY (invoice_id) REFERENCES billing.invoices (invoice_id),
    CONSTRAINT fk_invoice_boxes_box_id FOREIGN KEY (box_id) REFERENCES sample.boxes (box_id)
);